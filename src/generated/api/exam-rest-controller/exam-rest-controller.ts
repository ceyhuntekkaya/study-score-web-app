/**
 * Generated by orval v7.17.0 üç∫
 * Do not edit manually.
 * OpenAPI definition
 * OpenAPI spec version: v0
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import type {
  AddQuestionToExamParams,
  AddQuestionsFromTemplatesParams,
  DuplicateExamParams,
  ExamDto,
  ExamFilterDto,
  ExamPartDto,
  ExamQuestionDto,
  ExamStatisticsDto,
  ExistsByCodeParams,
  ExistsByNameParams,
  FindByCodeParams,
  GetExamDistributionByCategory200,
  GetExamDistributionByLevel200,
  GetPopularExamsParams,
  GetRecentExamsParams,
  SearchExamsParams,
  UpdateQuestionPointsParams,
} from "../openAPIDefinition.schemas";

import { customInstance } from "../../../lib/api-client";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

export const getExamById = (
  examId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ExamDto>(
    { url: `/exam/exams/${examId}`, method: "GET", signal },
    options,
  );
};

export const getGetExamByIdQueryKey = (examId?: string) => {
  return [`/exam/exams/${examId}`] as const;
};

export const getGetExamByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getExamById>>,
  TError = unknown,
>(
  examId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getExamById>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetExamByIdQueryKey(examId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getExamById>>> = ({
    signal,
  }) => getExamById(examId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!examId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getExamById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetExamByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getExamById>>
>;
export type GetExamByIdQueryError = unknown;

export function useGetExamById<
  TData = Awaited<ReturnType<typeof getExamById>>,
  TError = unknown,
>(
  examId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getExamById>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExamById>>,
          TError,
          Awaited<ReturnType<typeof getExamById>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExamById<
  TData = Awaited<ReturnType<typeof getExamById>>,
  TError = unknown,
>(
  examId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getExamById>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExamById>>,
          TError,
          Awaited<ReturnType<typeof getExamById>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExamById<
  TData = Awaited<ReturnType<typeof getExamById>>,
  TError = unknown,
>(
  examId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getExamById>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetExamById<
  TData = Awaited<ReturnType<typeof getExamById>>,
  TError = unknown,
>(
  examId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getExamById>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetExamByIdQueryOptions(examId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const updateExam = (
  examId: string,
  examDto: ExamDto,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<ExamDto>(
    {
      url: `/exam/exams/${examId}`,
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      data: examDto,
    },
    options,
  );
};

export const getUpdateExamMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateExam>>,
    TError,
    { examId: string; data: ExamDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateExam>>,
  TError,
  { examId: string; data: ExamDto },
  TContext
> => {
  const mutationKey = ["updateExam"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateExam>>,
    { examId: string; data: ExamDto }
  > = (props) => {
    const { examId, data } = props ?? {};

    return updateExam(examId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateExamMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateExam>>
>;
export type UpdateExamMutationBody = ExamDto;
export type UpdateExamMutationError = unknown;

export const useUpdateExam = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateExam>>,
      TError,
      { examId: string; data: ExamDto },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateExam>>,
  TError,
  { examId: string; data: ExamDto },
  TContext
> => {
  const mutationOptions = getUpdateExamMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const deleteExam = (
  examId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<string>(
    { url: `/exam/exams/${examId}`, method: "DELETE" },
    options,
  );
};

export const getDeleteExamMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteExam>>,
    TError,
    { examId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteExam>>,
  TError,
  { examId: string },
  TContext
> => {
  const mutationKey = ["deleteExam"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteExam>>,
    { examId: string }
  > = (props) => {
    const { examId } = props ?? {};

    return deleteExam(examId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteExamMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteExam>>
>;

export type DeleteExamMutationError = unknown;

export const useDeleteExam = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteExam>>,
      TError,
      { examId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteExam>>,
  TError,
  { examId: string },
  TContext
> => {
  const mutationOptions = getDeleteExamMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const unpublishExam = (
  examId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<ExamDto>(
    { url: `/exam/exams/${examId}/unpublish`, method: "PUT" },
    options,
  );
};

export const getUnpublishExamMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof unpublishExam>>,
    TError,
    { examId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof unpublishExam>>,
  TError,
  { examId: string },
  TContext
> => {
  const mutationKey = ["unpublishExam"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof unpublishExam>>,
    { examId: string }
  > = (props) => {
    const { examId } = props ?? {};

    return unpublishExam(examId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UnpublishExamMutationResult = NonNullable<
  Awaited<ReturnType<typeof unpublishExam>>
>;

export type UnpublishExamMutationError = unknown;

export const useUnpublishExam = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof unpublishExam>>,
      TError,
      { examId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof unpublishExam>>,
  TError,
  { examId: string },
  TContext
> => {
  const mutationOptions = getUnpublishExamMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const updateQuestionSettings = (
  examId: string,
  questionId: string,
  examQuestionDto: ExamQuestionDto,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<ExamDto>(
    {
      url: `/exam/exams/${examId}/questions/${questionId}/settings`,
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      data: examQuestionDto,
    },
    options,
  );
};

export const getUpdateQuestionSettingsMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateQuestionSettings>>,
    TError,
    { examId: string; questionId: string; data: ExamQuestionDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateQuestionSettings>>,
  TError,
  { examId: string; questionId: string; data: ExamQuestionDto },
  TContext
> => {
  const mutationKey = ["updateQuestionSettings"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateQuestionSettings>>,
    { examId: string; questionId: string; data: ExamQuestionDto }
  > = (props) => {
    const { examId, questionId, data } = props ?? {};

    return updateQuestionSettings(examId, questionId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateQuestionSettingsMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateQuestionSettings>>
>;
export type UpdateQuestionSettingsMutationBody = ExamQuestionDto;
export type UpdateQuestionSettingsMutationError = unknown;

export const useUpdateQuestionSettings = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateQuestionSettings>>,
      TError,
      { examId: string; questionId: string; data: ExamQuestionDto },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateQuestionSettings>>,
  TError,
  { examId: string; questionId: string; data: ExamQuestionDto },
  TContext
> => {
  const mutationOptions = getUpdateQuestionSettingsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const updateQuestionPoints = (
  examId: string,
  questionId: string,
  params: UpdateQuestionPointsParams,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<ExamDto>(
    {
      url: `/exam/exams/${examId}/questions/${questionId}/points`,
      method: "PUT",
      params,
    },
    options,
  );
};

export const getUpdateQuestionPointsMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateQuestionPoints>>,
    TError,
    { examId: string; questionId: string; params: UpdateQuestionPointsParams },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateQuestionPoints>>,
  TError,
  { examId: string; questionId: string; params: UpdateQuestionPointsParams },
  TContext
> => {
  const mutationKey = ["updateQuestionPoints"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateQuestionPoints>>,
    { examId: string; questionId: string; params: UpdateQuestionPointsParams }
  > = (props) => {
    const { examId, questionId, params } = props ?? {};

    return updateQuestionPoints(examId, questionId, params, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateQuestionPointsMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateQuestionPoints>>
>;

export type UpdateQuestionPointsMutationError = unknown;

export const useUpdateQuestionPoints = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateQuestionPoints>>,
      TError,
      {
        examId: string;
        questionId: string;
        params: UpdateQuestionPointsParams;
      },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateQuestionPoints>>,
  TError,
  { examId: string; questionId: string; params: UpdateQuestionPointsParams },
  TContext
> => {
  const mutationOptions = getUpdateQuestionPointsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const reorderQuestions = (
  examId: string,
  reorderQuestionsBody: string[],
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<ExamDto>(
    {
      url: `/exam/exams/${examId}/questions/reorder`,
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      data: reorderQuestionsBody,
    },
    options,
  );
};

export const getReorderQuestionsMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof reorderQuestions>>,
    TError,
    { examId: string; data: string[] },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof reorderQuestions>>,
  TError,
  { examId: string; data: string[] },
  TContext
> => {
  const mutationKey = ["reorderQuestions"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof reorderQuestions>>,
    { examId: string; data: string[] }
  > = (props) => {
    const { examId, data } = props ?? {};

    return reorderQuestions(examId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ReorderQuestionsMutationResult = NonNullable<
  Awaited<ReturnType<typeof reorderQuestions>>
>;
export type ReorderQuestionsMutationBody = string[];
export type ReorderQuestionsMutationError = unknown;

export const useReorderQuestions = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof reorderQuestions>>,
      TError,
      { examId: string; data: string[] },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof reorderQuestions>>,
  TError,
  { examId: string; data: string[] },
  TContext
> => {
  const mutationOptions = getReorderQuestionsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const publishExam = (
  examId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<ExamDto>(
    { url: `/exam/exams/${examId}/publish`, method: "PUT" },
    options,
  );
};

export const getPublishExamMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof publishExam>>,
    TError,
    { examId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof publishExam>>,
  TError,
  { examId: string },
  TContext
> => {
  const mutationKey = ["publishExam"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof publishExam>>,
    { examId: string }
  > = (props) => {
    const { examId } = props ?? {};

    return publishExam(examId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PublishExamMutationResult = NonNullable<
  Awaited<ReturnType<typeof publishExam>>
>;

export type PublishExamMutationError = unknown;

export const usePublishExam = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof publishExam>>,
      TError,
      { examId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof publishExam>>,
  TError,
  { examId: string },
  TContext
> => {
  const mutationOptions = getPublishExamMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const updateExamPart = (
  examId: string,
  partId: string,
  examPartDto: ExamPartDto,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<ExamDto>(
    {
      url: `/exam/exams/${examId}/parts/${partId}`,
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      data: examPartDto,
    },
    options,
  );
};

export const getUpdateExamPartMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateExamPart>>,
    TError,
    { examId: string; partId: string; data: ExamPartDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateExamPart>>,
  TError,
  { examId: string; partId: string; data: ExamPartDto },
  TContext
> => {
  const mutationKey = ["updateExamPart"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateExamPart>>,
    { examId: string; partId: string; data: ExamPartDto }
  > = (props) => {
    const { examId, partId, data } = props ?? {};

    return updateExamPart(examId, partId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateExamPartMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateExamPart>>
>;
export type UpdateExamPartMutationBody = ExamPartDto;
export type UpdateExamPartMutationError = unknown;

export const useUpdateExamPart = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateExamPart>>,
      TError,
      { examId: string; partId: string; data: ExamPartDto },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateExamPart>>,
  TError,
  { examId: string; partId: string; data: ExamPartDto },
  TContext
> => {
  const mutationOptions = getUpdateExamPartMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const removeExamPart = (
  examId: string,
  partId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<ExamDto>(
    { url: `/exam/exams/${examId}/parts/${partId}`, method: "DELETE" },
    options,
  );
};

export const getRemoveExamPartMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeExamPart>>,
    TError,
    { examId: string; partId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeExamPart>>,
  TError,
  { examId: string; partId: string },
  TContext
> => {
  const mutationKey = ["removeExamPart"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeExamPart>>,
    { examId: string; partId: string }
  > = (props) => {
    const { examId, partId } = props ?? {};

    return removeExamPart(examId, partId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveExamPartMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeExamPart>>
>;

export type RemoveExamPartMutationError = unknown;

export const useRemoveExamPart = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof removeExamPart>>,
      TError,
      { examId: string; partId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof removeExamPart>>,
  TError,
  { examId: string; partId: string },
  TContext
> => {
  const mutationOptions = getRemoveExamPartMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const reorderParts = (
  examId: string,
  reorderPartsBody: string[],
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<ExamDto>(
    {
      url: `/exam/exams/${examId}/parts/reorder`,
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      data: reorderPartsBody,
    },
    options,
  );
};

export const getReorderPartsMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof reorderParts>>,
    TError,
    { examId: string; data: string[] },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof reorderParts>>,
  TError,
  { examId: string; data: string[] },
  TContext
> => {
  const mutationKey = ["reorderParts"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof reorderParts>>,
    { examId: string; data: string[] }
  > = (props) => {
    const { examId, data } = props ?? {};

    return reorderParts(examId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ReorderPartsMutationResult = NonNullable<
  Awaited<ReturnType<typeof reorderParts>>
>;
export type ReorderPartsMutationBody = string[];
export type ReorderPartsMutationError = unknown;

export const useReorderParts = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof reorderParts>>,
      TError,
      { examId: string; data: string[] },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof reorderParts>>,
  TError,
  { examId: string; data: string[] },
  TContext
> => {
  const mutationOptions = getReorderPartsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const deactivateExam = (
  examId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<ExamDto>(
    { url: `/exam/exams/${examId}/deactivate`, method: "PUT" },
    options,
  );
};

export const getDeactivateExamMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deactivateExam>>,
    TError,
    { examId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deactivateExam>>,
  TError,
  { examId: string },
  TContext
> => {
  const mutationKey = ["deactivateExam"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deactivateExam>>,
    { examId: string }
  > = (props) => {
    const { examId } = props ?? {};

    return deactivateExam(examId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeactivateExamMutationResult = NonNullable<
  Awaited<ReturnType<typeof deactivateExam>>
>;

export type DeactivateExamMutationError = unknown;

export const useDeactivateExam = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deactivateExam>>,
      TError,
      { examId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deactivateExam>>,
  TError,
  { examId: string },
  TContext
> => {
  const mutationOptions = getDeactivateExamMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const activateExam = (
  examId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<ExamDto>(
    { url: `/exam/exams/${examId}/activate`, method: "PUT" },
    options,
  );
};

export const getActivateExamMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof activateExam>>,
    TError,
    { examId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof activateExam>>,
  TError,
  { examId: string },
  TContext
> => {
  const mutationKey = ["activateExam"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof activateExam>>,
    { examId: string }
  > = (props) => {
    const { examId } = props ?? {};

    return activateExam(examId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ActivateExamMutationResult = NonNullable<
  Awaited<ReturnType<typeof activateExam>>
>;

export type ActivateExamMutationError = unknown;

export const useActivateExam = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof activateExam>>,
      TError,
      { examId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof activateExam>>,
  TError,
  { examId: string },
  TContext
> => {
  const mutationOptions = getActivateExamMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const publishMultipleExams = (
  publishMultipleExamsBody: string[],
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<ExamDto[]>(
    {
      url: `/exam/exams/bulk-publish`,
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      data: publishMultipleExamsBody,
    },
    options,
  );
};

export const getPublishMultipleExamsMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof publishMultipleExams>>,
    TError,
    { data: string[] },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof publishMultipleExams>>,
  TError,
  { data: string[] },
  TContext
> => {
  const mutationKey = ["publishMultipleExams"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof publishMultipleExams>>,
    { data: string[] }
  > = (props) => {
    const { data } = props ?? {};

    return publishMultipleExams(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PublishMultipleExamsMutationResult = NonNullable<
  Awaited<ReturnType<typeof publishMultipleExams>>
>;
export type PublishMultipleExamsMutationBody = string[];
export type PublishMultipleExamsMutationError = unknown;

export const usePublishMultipleExams = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof publishMultipleExams>>,
      TError,
      { data: string[] },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof publishMultipleExams>>,
  TError,
  { data: string[] },
  TContext
> => {
  const mutationOptions = getPublishMultipleExamsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const addQuestionToExam = (
  examId: string,
  params: AddQuestionToExamParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ExamDto>(
    { url: `/exam/exams/${examId}/questions`, method: "POST", params, signal },
    options,
  );
};

export const getAddQuestionToExamMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addQuestionToExam>>,
    TError,
    { examId: string; params: AddQuestionToExamParams },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof addQuestionToExam>>,
  TError,
  { examId: string; params: AddQuestionToExamParams },
  TContext
> => {
  const mutationKey = ["addQuestionToExam"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addQuestionToExam>>,
    { examId: string; params: AddQuestionToExamParams }
  > = (props) => {
    const { examId, params } = props ?? {};

    return addQuestionToExam(examId, params, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AddQuestionToExamMutationResult = NonNullable<
  Awaited<ReturnType<typeof addQuestionToExam>>
>;

export type AddQuestionToExamMutationError = unknown;

export const useAddQuestionToExam = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof addQuestionToExam>>,
      TError,
      { examId: string; params: AddQuestionToExamParams },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof addQuestionToExam>>,
  TError,
  { examId: string; params: AddQuestionToExamParams },
  TContext
> => {
  const mutationOptions = getAddQuestionToExamMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const addQuestionsFromTemplates = (
  examId: string,
  addQuestionsFromTemplatesBody: string[],
  params?: AddQuestionsFromTemplatesParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ExamDto>(
    {
      url: `/exam/exams/${examId}/questions-from-templates`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: addQuestionsFromTemplatesBody,
      params,
      signal,
    },
    options,
  );
};

export const getAddQuestionsFromTemplatesMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addQuestionsFromTemplates>>,
    TError,
    {
      examId: string;
      data: string[];
      params?: AddQuestionsFromTemplatesParams;
    },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof addQuestionsFromTemplates>>,
  TError,
  { examId: string; data: string[]; params?: AddQuestionsFromTemplatesParams },
  TContext
> => {
  const mutationKey = ["addQuestionsFromTemplates"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addQuestionsFromTemplates>>,
    { examId: string; data: string[]; params?: AddQuestionsFromTemplatesParams }
  > = (props) => {
    const { examId, data, params } = props ?? {};

    return addQuestionsFromTemplates(examId, data, params, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AddQuestionsFromTemplatesMutationResult = NonNullable<
  Awaited<ReturnType<typeof addQuestionsFromTemplates>>
>;
export type AddQuestionsFromTemplatesMutationBody = string[];
export type AddQuestionsFromTemplatesMutationError = unknown;

export const useAddQuestionsFromTemplates = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof addQuestionsFromTemplates>>,
      TError,
      {
        examId: string;
        data: string[];
        params?: AddQuestionsFromTemplatesParams;
      },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof addQuestionsFromTemplates>>,
  TError,
  { examId: string; data: string[]; params?: AddQuestionsFromTemplatesParams },
  TContext
> => {
  const mutationOptions = getAddQuestionsFromTemplatesMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const addExamPart = (
  examId: string,
  examPartDto: ExamPartDto,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ExamDto>(
    {
      url: `/exam/exams/${examId}/parts`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: examPartDto,
      signal,
    },
    options,
  );
};

export const getAddExamPartMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addExamPart>>,
    TError,
    { examId: string; data: ExamPartDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof addExamPart>>,
  TError,
  { examId: string; data: ExamPartDto },
  TContext
> => {
  const mutationKey = ["addExamPart"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addExamPart>>,
    { examId: string; data: ExamPartDto }
  > = (props) => {
    const { examId, data } = props ?? {};

    return addExamPart(examId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AddExamPartMutationResult = NonNullable<
  Awaited<ReturnType<typeof addExamPart>>
>;
export type AddExamPartMutationBody = ExamPartDto;
export type AddExamPartMutationError = unknown;

export const useAddExamPart = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof addExamPart>>,
      TError,
      { examId: string; data: ExamPartDto },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof addExamPart>>,
  TError,
  { examId: string; data: ExamPartDto },
  TContext
> => {
  const mutationOptions = getAddExamPartMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const duplicateExam = (
  examId: string,
  params: DuplicateExamParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ExamDto>(
    { url: `/exam/exams/${examId}/duplicate`, method: "POST", params, signal },
    options,
  );
};

export const getDuplicateExamMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof duplicateExam>>,
    TError,
    { examId: string; params: DuplicateExamParams },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof duplicateExam>>,
  TError,
  { examId: string; params: DuplicateExamParams },
  TContext
> => {
  const mutationKey = ["duplicateExam"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof duplicateExam>>,
    { examId: string; params: DuplicateExamParams }
  > = (props) => {
    const { examId, params } = props ?? {};

    return duplicateExam(examId, params, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DuplicateExamMutationResult = NonNullable<
  Awaited<ReturnType<typeof duplicateExam>>
>;

export type DuplicateExamMutationError = unknown;

export const useDuplicateExam = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof duplicateExam>>,
      TError,
      { examId: string; params: DuplicateExamParams },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof duplicateExam>>,
  TError,
  { examId: string; params: DuplicateExamParams },
  TContext
> => {
  const mutationOptions = getDuplicateExamMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const filterExams = (
  examFilterDto: ExamFilterDto,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ExamDto[]>(
    {
      url: `/exam/exams/filter`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: examFilterDto,
      signal,
    },
    options,
  );
};

export const getFilterExamsMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof filterExams>>,
    TError,
    { data: ExamFilterDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof filterExams>>,
  TError,
  { data: ExamFilterDto },
  TContext
> => {
  const mutationKey = ["filterExams"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof filterExams>>,
    { data: ExamFilterDto }
  > = (props) => {
    const { data } = props ?? {};

    return filterExams(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type FilterExamsMutationResult = NonNullable<
  Awaited<ReturnType<typeof filterExams>>
>;
export type FilterExamsMutationBody = ExamFilterDto;
export type FilterExamsMutationError = unknown;

export const useFilterExams = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof filterExams>>,
      TError,
      { data: ExamFilterDto },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof filterExams>>,
  TError,
  { data: ExamFilterDto },
  TContext
> => {
  const mutationOptions = getFilterExamsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const createMultipleExams = (
  examDto: ExamDto[],
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ExamDto[]>(
    {
      url: `/exam/exams/bulk-create`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: examDto,
      signal,
    },
    options,
  );
};

export const getCreateMultipleExamsMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createMultipleExams>>,
    TError,
    { data: ExamDto[] },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createMultipleExams>>,
  TError,
  { data: ExamDto[] },
  TContext
> => {
  const mutationKey = ["createMultipleExams"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createMultipleExams>>,
    { data: ExamDto[] }
  > = (props) => {
    const { data } = props ?? {};

    return createMultipleExams(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateMultipleExamsMutationResult = NonNullable<
  Awaited<ReturnType<typeof createMultipleExams>>
>;
export type CreateMultipleExamsMutationBody = ExamDto[];
export type CreateMultipleExamsMutationError = unknown;

export const useCreateMultipleExams = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createMultipleExams>>,
      TError,
      { data: ExamDto[] },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createMultipleExams>>,
  TError,
  { data: ExamDto[] },
  TContext
> => {
  const mutationOptions = getCreateMultipleExamsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const getAllExams = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ExamDto[]>(
    { url: `/exam/exams/`, method: "GET", signal },
    options,
  );
};

export const getGetAllExamsQueryKey = () => {
  return [`/exam/exams/`] as const;
};

export const getGetAllExamsQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllExams>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAllExams>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllExamsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllExams>>> = ({
    signal,
  }) => getAllExams(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAllExams>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAllExamsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllExams>>
>;
export type GetAllExamsQueryError = unknown;

export function useGetAllExams<
  TData = Awaited<ReturnType<typeof getAllExams>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllExams>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllExams>>,
          TError,
          Awaited<ReturnType<typeof getAllExams>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAllExams<
  TData = Awaited<ReturnType<typeof getAllExams>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllExams>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllExams>>,
          TError,
          Awaited<ReturnType<typeof getAllExams>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAllExams<
  TData = Awaited<ReturnType<typeof getAllExams>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllExams>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetAllExams<
  TData = Awaited<ReturnType<typeof getAllExams>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllExams>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAllExamsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const createExam = (
  examDto: ExamDto,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ExamDto>(
    {
      url: `/exam/exams/`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: examDto,
      signal,
    },
    options,
  );
};

export const getCreateExamMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createExam>>,
    TError,
    { data: ExamDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createExam>>,
  TError,
  { data: ExamDto },
  TContext
> => {
  const mutationKey = ["createExam"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createExam>>,
    { data: ExamDto }
  > = (props) => {
    const { data } = props ?? {};

    return createExam(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateExamMutationResult = NonNullable<
  Awaited<ReturnType<typeof createExam>>
>;
export type CreateExamMutationBody = ExamDto;
export type CreateExamMutationError = unknown;

export const useCreateExam = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createExam>>,
      TError,
      { data: ExamDto },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createExam>>,
  TError,
  { data: ExamDto },
  TContext
> => {
  const mutationOptions = getCreateExamMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const getExamValidationErrors = (
  examId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<string[]>(
    { url: `/exam/exams/${examId}/validation-errors`, method: "GET", signal },
    options,
  );
};

export const getGetExamValidationErrorsQueryKey = (examId?: string) => {
  return [`/exam/exams/${examId}/validation-errors`] as const;
};

export const getGetExamValidationErrorsQueryOptions = <
  TData = Awaited<ReturnType<typeof getExamValidationErrors>>,
  TError = unknown,
>(
  examId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamValidationErrors>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetExamValidationErrorsQueryKey(examId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getExamValidationErrors>>
  > = ({ signal }) => getExamValidationErrors(examId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!examId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getExamValidationErrors>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetExamValidationErrorsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getExamValidationErrors>>
>;
export type GetExamValidationErrorsQueryError = unknown;

export function useGetExamValidationErrors<
  TData = Awaited<ReturnType<typeof getExamValidationErrors>>,
  TError = unknown,
>(
  examId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamValidationErrors>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExamValidationErrors>>,
          TError,
          Awaited<ReturnType<typeof getExamValidationErrors>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExamValidationErrors<
  TData = Awaited<ReturnType<typeof getExamValidationErrors>>,
  TError = unknown,
>(
  examId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamValidationErrors>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExamValidationErrors>>,
          TError,
          Awaited<ReturnType<typeof getExamValidationErrors>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExamValidationErrors<
  TData = Awaited<ReturnType<typeof getExamValidationErrors>>,
  TError = unknown,
>(
  examId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamValidationErrors>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetExamValidationErrors<
  TData = Awaited<ReturnType<typeof getExamValidationErrors>>,
  TError = unknown,
>(
  examId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamValidationErrors>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetExamValidationErrorsQueryOptions(examId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const validateExam = (
  examId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<boolean>(
    { url: `/exam/exams/${examId}/validate`, method: "GET", signal },
    options,
  );
};

export const getValidateExamQueryKey = (examId?: string) => {
  return [`/exam/exams/${examId}/validate`] as const;
};

export const getValidateExamQueryOptions = <
  TData = Awaited<ReturnType<typeof validateExam>>,
  TError = unknown,
>(
  examId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof validateExam>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getValidateExamQueryKey(examId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof validateExam>>> = ({
    signal,
  }) => validateExam(examId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!examId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof validateExam>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ValidateExamQueryResult = NonNullable<
  Awaited<ReturnType<typeof validateExam>>
>;
export type ValidateExamQueryError = unknown;

export function useValidateExam<
  TData = Awaited<ReturnType<typeof validateExam>>,
  TError = unknown,
>(
  examId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof validateExam>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof validateExam>>,
          TError,
          Awaited<ReturnType<typeof validateExam>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useValidateExam<
  TData = Awaited<ReturnType<typeof validateExam>>,
  TError = unknown,
>(
  examId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof validateExam>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof validateExam>>,
          TError,
          Awaited<ReturnType<typeof validateExam>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useValidateExam<
  TData = Awaited<ReturnType<typeof validateExam>>,
  TError = unknown,
>(
  examId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof validateExam>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useValidateExam<
  TData = Awaited<ReturnType<typeof validateExam>>,
  TError = unknown,
>(
  examId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof validateExam>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getValidateExamQueryOptions(examId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const calculateTotalPoints = (
  examId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<number>(
    { url: `/exam/exams/${examId}/total-points`, method: "GET", signal },
    options,
  );
};

export const getCalculateTotalPointsQueryKey = (examId?: string) => {
  return [`/exam/exams/${examId}/total-points`] as const;
};

export const getCalculateTotalPointsQueryOptions = <
  TData = Awaited<ReturnType<typeof calculateTotalPoints>>,
  TError = unknown,
>(
  examId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof calculateTotalPoints>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getCalculateTotalPointsQueryKey(examId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof calculateTotalPoints>>
  > = ({ signal }) => calculateTotalPoints(examId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!examId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof calculateTotalPoints>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type CalculateTotalPointsQueryResult = NonNullable<
  Awaited<ReturnType<typeof calculateTotalPoints>>
>;
export type CalculateTotalPointsQueryError = unknown;

export function useCalculateTotalPoints<
  TData = Awaited<ReturnType<typeof calculateTotalPoints>>,
  TError = unknown,
>(
  examId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof calculateTotalPoints>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof calculateTotalPoints>>,
          TError,
          Awaited<ReturnType<typeof calculateTotalPoints>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCalculateTotalPoints<
  TData = Awaited<ReturnType<typeof calculateTotalPoints>>,
  TError = unknown,
>(
  examId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof calculateTotalPoints>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof calculateTotalPoints>>,
          TError,
          Awaited<ReturnType<typeof calculateTotalPoints>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCalculateTotalPoints<
  TData = Awaited<ReturnType<typeof calculateTotalPoints>>,
  TError = unknown,
>(
  examId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof calculateTotalPoints>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useCalculateTotalPoints<
  TData = Awaited<ReturnType<typeof calculateTotalPoints>>,
  TError = unknown,
>(
  examId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof calculateTotalPoints>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getCalculateTotalPointsQueryOptions(examId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getExamStatistics = (
  examId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ExamStatisticsDto>(
    { url: `/exam/exams/${examId}/statistics`, method: "GET", signal },
    options,
  );
};

export const getGetExamStatisticsQueryKey = (examId?: string) => {
  return [`/exam/exams/${examId}/statistics`] as const;
};

export const getGetExamStatisticsQueryOptions = <
  TData = Awaited<ReturnType<typeof getExamStatistics>>,
  TError = unknown,
>(
  examId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamStatistics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetExamStatisticsQueryKey(examId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getExamStatistics>>
  > = ({ signal }) => getExamStatistics(examId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!examId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getExamStatistics>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetExamStatisticsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getExamStatistics>>
>;
export type GetExamStatisticsQueryError = unknown;

export function useGetExamStatistics<
  TData = Awaited<ReturnType<typeof getExamStatistics>>,
  TError = unknown,
>(
  examId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamStatistics>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExamStatistics>>,
          TError,
          Awaited<ReturnType<typeof getExamStatistics>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExamStatistics<
  TData = Awaited<ReturnType<typeof getExamStatistics>>,
  TError = unknown,
>(
  examId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamStatistics>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExamStatistics>>,
          TError,
          Awaited<ReturnType<typeof getExamStatistics>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExamStatistics<
  TData = Awaited<ReturnType<typeof getExamStatistics>>,
  TError = unknown,
>(
  examId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamStatistics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetExamStatistics<
  TData = Awaited<ReturnType<typeof getExamStatistics>>,
  TError = unknown,
>(
  examId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamStatistics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetExamStatisticsQueryOptions(examId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const calculateEstimatedDuration = (
  examId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<number>(
    { url: `/exam/exams/${examId}/estimated-duration`, method: "GET", signal },
    options,
  );
};

export const getCalculateEstimatedDurationQueryKey = (examId?: string) => {
  return [`/exam/exams/${examId}/estimated-duration`] as const;
};

export const getCalculateEstimatedDurationQueryOptions = <
  TData = Awaited<ReturnType<typeof calculateEstimatedDuration>>,
  TError = unknown,
>(
  examId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof calculateEstimatedDuration>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getCalculateEstimatedDurationQueryKey(examId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof calculateEstimatedDuration>>
  > = ({ signal }) =>
    calculateEstimatedDuration(examId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!examId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof calculateEstimatedDuration>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type CalculateEstimatedDurationQueryResult = NonNullable<
  Awaited<ReturnType<typeof calculateEstimatedDuration>>
>;
export type CalculateEstimatedDurationQueryError = unknown;

export function useCalculateEstimatedDuration<
  TData = Awaited<ReturnType<typeof calculateEstimatedDuration>>,
  TError = unknown,
>(
  examId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof calculateEstimatedDuration>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof calculateEstimatedDuration>>,
          TError,
          Awaited<ReturnType<typeof calculateEstimatedDuration>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCalculateEstimatedDuration<
  TData = Awaited<ReturnType<typeof calculateEstimatedDuration>>,
  TError = unknown,
>(
  examId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof calculateEstimatedDuration>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof calculateEstimatedDuration>>,
          TError,
          Awaited<ReturnType<typeof calculateEstimatedDuration>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCalculateEstimatedDuration<
  TData = Awaited<ReturnType<typeof calculateEstimatedDuration>>,
  TError = unknown,
>(
  examId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof calculateEstimatedDuration>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useCalculateEstimatedDuration<
  TData = Awaited<ReturnType<typeof calculateEstimatedDuration>>,
  TError = unknown,
>(
  examId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof calculateEstimatedDuration>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getCalculateEstimatedDurationQueryOptions(
    examId,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getExamsWithoutQuestions = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ExamDto[]>(
    { url: `/exam/exams/without-questions`, method: "GET", signal },
    options,
  );
};

export const getGetExamsWithoutQuestionsQueryKey = () => {
  return [`/exam/exams/without-questions`] as const;
};

export const getGetExamsWithoutQuestionsQueryOptions = <
  TData = Awaited<ReturnType<typeof getExamsWithoutQuestions>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getExamsWithoutQuestions>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetExamsWithoutQuestionsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getExamsWithoutQuestions>>
  > = ({ signal }) => getExamsWithoutQuestions(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getExamsWithoutQuestions>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetExamsWithoutQuestionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getExamsWithoutQuestions>>
>;
export type GetExamsWithoutQuestionsQueryError = unknown;

export function useGetExamsWithoutQuestions<
  TData = Awaited<ReturnType<typeof getExamsWithoutQuestions>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamsWithoutQuestions>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExamsWithoutQuestions>>,
          TError,
          Awaited<ReturnType<typeof getExamsWithoutQuestions>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExamsWithoutQuestions<
  TData = Awaited<ReturnType<typeof getExamsWithoutQuestions>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamsWithoutQuestions>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExamsWithoutQuestions>>,
          TError,
          Awaited<ReturnType<typeof getExamsWithoutQuestions>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExamsWithoutQuestions<
  TData = Awaited<ReturnType<typeof getExamsWithoutQuestions>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamsWithoutQuestions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetExamsWithoutQuestions<
  TData = Awaited<ReturnType<typeof getExamsWithoutQuestions>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamsWithoutQuestions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetExamsWithoutQuestionsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getExamsWithoutParts = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ExamDto[]>(
    { url: `/exam/exams/without-parts`, method: "GET", signal },
    options,
  );
};

export const getGetExamsWithoutPartsQueryKey = () => {
  return [`/exam/exams/without-parts`] as const;
};

export const getGetExamsWithoutPartsQueryOptions = <
  TData = Awaited<ReturnType<typeof getExamsWithoutParts>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getExamsWithoutParts>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetExamsWithoutPartsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getExamsWithoutParts>>
  > = ({ signal }) => getExamsWithoutParts(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getExamsWithoutParts>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetExamsWithoutPartsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getExamsWithoutParts>>
>;
export type GetExamsWithoutPartsQueryError = unknown;

export function useGetExamsWithoutParts<
  TData = Awaited<ReturnType<typeof getExamsWithoutParts>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamsWithoutParts>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExamsWithoutParts>>,
          TError,
          Awaited<ReturnType<typeof getExamsWithoutParts>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExamsWithoutParts<
  TData = Awaited<ReturnType<typeof getExamsWithoutParts>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamsWithoutParts>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExamsWithoutParts>>,
          TError,
          Awaited<ReturnType<typeof getExamsWithoutParts>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExamsWithoutParts<
  TData = Awaited<ReturnType<typeof getExamsWithoutParts>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamsWithoutParts>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetExamsWithoutParts<
  TData = Awaited<ReturnType<typeof getExamsWithoutParts>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamsWithoutParts>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetExamsWithoutPartsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getTotalExamCount = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<number>(
    { url: `/exam/exams/statistics/total-count`, method: "GET", signal },
    options,
  );
};

export const getGetTotalExamCountQueryKey = () => {
  return [`/exam/exams/statistics/total-count`] as const;
};

export const getGetTotalExamCountQueryOptions = <
  TData = Awaited<ReturnType<typeof getTotalExamCount>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getTotalExamCount>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTotalExamCountQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTotalExamCount>>
  > = ({ signal }) => getTotalExamCount(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getTotalExamCount>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTotalExamCountQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTotalExamCount>>
>;
export type GetTotalExamCountQueryError = unknown;

export function useGetTotalExamCount<
  TData = Awaited<ReturnType<typeof getTotalExamCount>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTotalExamCount>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTotalExamCount>>,
          TError,
          Awaited<ReturnType<typeof getTotalExamCount>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTotalExamCount<
  TData = Awaited<ReturnType<typeof getTotalExamCount>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTotalExamCount>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTotalExamCount>>,
          TError,
          Awaited<ReturnType<typeof getTotalExamCount>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTotalExamCount<
  TData = Awaited<ReturnType<typeof getTotalExamCount>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTotalExamCount>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetTotalExamCount<
  TData = Awaited<ReturnType<typeof getTotalExamCount>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTotalExamCount>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetTotalExamCountQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getExamDistributionByLevel = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetExamDistributionByLevel200>(
    {
      url: `/exam/exams/statistics/distribution-by-level`,
      method: "GET",
      signal,
    },
    options,
  );
};

export const getGetExamDistributionByLevelQueryKey = () => {
  return [`/exam/exams/statistics/distribution-by-level`] as const;
};

export const getGetExamDistributionByLevelQueryOptions = <
  TData = Awaited<ReturnType<typeof getExamDistributionByLevel>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getExamDistributionByLevel>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetExamDistributionByLevelQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getExamDistributionByLevel>>
  > = ({ signal }) => getExamDistributionByLevel(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getExamDistributionByLevel>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetExamDistributionByLevelQueryResult = NonNullable<
  Awaited<ReturnType<typeof getExamDistributionByLevel>>
>;
export type GetExamDistributionByLevelQueryError = unknown;

export function useGetExamDistributionByLevel<
  TData = Awaited<ReturnType<typeof getExamDistributionByLevel>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamDistributionByLevel>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExamDistributionByLevel>>,
          TError,
          Awaited<ReturnType<typeof getExamDistributionByLevel>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExamDistributionByLevel<
  TData = Awaited<ReturnType<typeof getExamDistributionByLevel>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamDistributionByLevel>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExamDistributionByLevel>>,
          TError,
          Awaited<ReturnType<typeof getExamDistributionByLevel>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExamDistributionByLevel<
  TData = Awaited<ReturnType<typeof getExamDistributionByLevel>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamDistributionByLevel>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetExamDistributionByLevel<
  TData = Awaited<ReturnType<typeof getExamDistributionByLevel>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamDistributionByLevel>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetExamDistributionByLevelQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getExamDistributionByCategory = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetExamDistributionByCategory200>(
    {
      url: `/exam/exams/statistics/distribution-by-category`,
      method: "GET",
      signal,
    },
    options,
  );
};

export const getGetExamDistributionByCategoryQueryKey = () => {
  return [`/exam/exams/statistics/distribution-by-category`] as const;
};

export const getGetExamDistributionByCategoryQueryOptions = <
  TData = Awaited<ReturnType<typeof getExamDistributionByCategory>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getExamDistributionByCategory>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetExamDistributionByCategoryQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getExamDistributionByCategory>>
  > = ({ signal }) => getExamDistributionByCategory(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getExamDistributionByCategory>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetExamDistributionByCategoryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getExamDistributionByCategory>>
>;
export type GetExamDistributionByCategoryQueryError = unknown;

export function useGetExamDistributionByCategory<
  TData = Awaited<ReturnType<typeof getExamDistributionByCategory>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamDistributionByCategory>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExamDistributionByCategory>>,
          TError,
          Awaited<ReturnType<typeof getExamDistributionByCategory>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExamDistributionByCategory<
  TData = Awaited<ReturnType<typeof getExamDistributionByCategory>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamDistributionByCategory>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExamDistributionByCategory>>,
          TError,
          Awaited<ReturnType<typeof getExamDistributionByCategory>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExamDistributionByCategory<
  TData = Awaited<ReturnType<typeof getExamDistributionByCategory>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamDistributionByCategory>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetExamDistributionByCategory<
  TData = Awaited<ReturnType<typeof getExamDistributionByCategory>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamDistributionByCategory>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetExamDistributionByCategoryQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const searchExams = (
  params: SearchExamsParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ExamDto[]>(
    { url: `/exam/exams/search`, method: "GET", params, signal },
    options,
  );
};

export const getSearchExamsQueryKey = (params?: SearchExamsParams) => {
  return [`/exam/exams/search`, ...(params ? [params] : [])] as const;
};

export const getSearchExamsQueryOptions = <
  TData = Awaited<ReturnType<typeof searchExams>>,
  TError = unknown,
>(
  params: SearchExamsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof searchExams>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSearchExamsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof searchExams>>> = ({
    signal,
  }) => searchExams(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof searchExams>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SearchExamsQueryResult = NonNullable<
  Awaited<ReturnType<typeof searchExams>>
>;
export type SearchExamsQueryError = unknown;

export function useSearchExams<
  TData = Awaited<ReturnType<typeof searchExams>>,
  TError = unknown,
>(
  params: SearchExamsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof searchExams>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchExams>>,
          TError,
          Awaited<ReturnType<typeof searchExams>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSearchExams<
  TData = Awaited<ReturnType<typeof searchExams>>,
  TError = unknown,
>(
  params: SearchExamsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof searchExams>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchExams>>,
          TError,
          Awaited<ReturnType<typeof searchExams>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSearchExams<
  TData = Awaited<ReturnType<typeof searchExams>>,
  TError = unknown,
>(
  params: SearchExamsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof searchExams>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useSearchExams<
  TData = Awaited<ReturnType<typeof searchExams>>,
  TError = unknown,
>(
  params: SearchExamsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof searchExams>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSearchExamsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getExamsRequiringValidation = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ExamDto[]>(
    { url: `/exam/exams/requiring-validation`, method: "GET", signal },
    options,
  );
};

export const getGetExamsRequiringValidationQueryKey = () => {
  return [`/exam/exams/requiring-validation`] as const;
};

export const getGetExamsRequiringValidationQueryOptions = <
  TData = Awaited<ReturnType<typeof getExamsRequiringValidation>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getExamsRequiringValidation>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetExamsRequiringValidationQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getExamsRequiringValidation>>
  > = ({ signal }) => getExamsRequiringValidation(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getExamsRequiringValidation>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetExamsRequiringValidationQueryResult = NonNullable<
  Awaited<ReturnType<typeof getExamsRequiringValidation>>
>;
export type GetExamsRequiringValidationQueryError = unknown;

export function useGetExamsRequiringValidation<
  TData = Awaited<ReturnType<typeof getExamsRequiringValidation>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamsRequiringValidation>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExamsRequiringValidation>>,
          TError,
          Awaited<ReturnType<typeof getExamsRequiringValidation>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExamsRequiringValidation<
  TData = Awaited<ReturnType<typeof getExamsRequiringValidation>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamsRequiringValidation>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExamsRequiringValidation>>,
          TError,
          Awaited<ReturnType<typeof getExamsRequiringValidation>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExamsRequiringValidation<
  TData = Awaited<ReturnType<typeof getExamsRequiringValidation>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamsRequiringValidation>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetExamsRequiringValidation<
  TData = Awaited<ReturnType<typeof getExamsRequiringValidation>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamsRequiringValidation>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetExamsRequiringValidationQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getRecentExams = (
  params?: GetRecentExamsParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ExamDto[]>(
    { url: `/exam/exams/recent`, method: "GET", params, signal },
    options,
  );
};

export const getGetRecentExamsQueryKey = (params?: GetRecentExamsParams) => {
  return [`/exam/exams/recent`, ...(params ? [params] : [])] as const;
};

export const getGetRecentExamsQueryOptions = <
  TData = Awaited<ReturnType<typeof getRecentExams>>,
  TError = unknown,
>(
  params?: GetRecentExamsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRecentExams>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRecentExamsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRecentExams>>> = ({
    signal,
  }) => getRecentExams(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getRecentExams>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetRecentExamsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRecentExams>>
>;
export type GetRecentExamsQueryError = unknown;

export function useGetRecentExams<
  TData = Awaited<ReturnType<typeof getRecentExams>>,
  TError = unknown,
>(
  params: undefined | GetRecentExamsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRecentExams>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecentExams>>,
          TError,
          Awaited<ReturnType<typeof getRecentExams>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRecentExams<
  TData = Awaited<ReturnType<typeof getRecentExams>>,
  TError = unknown,
>(
  params?: GetRecentExamsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRecentExams>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecentExams>>,
          TError,
          Awaited<ReturnType<typeof getRecentExams>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRecentExams<
  TData = Awaited<ReturnType<typeof getRecentExams>>,
  TError = unknown,
>(
  params?: GetRecentExamsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRecentExams>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetRecentExams<
  TData = Awaited<ReturnType<typeof getRecentExams>>,
  TError = unknown,
>(
  params?: GetRecentExamsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRecentExams>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetRecentExamsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getPublishedExams = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ExamDto[]>(
    { url: `/exam/exams/published`, method: "GET", signal },
    options,
  );
};

export const getGetPublishedExamsQueryKey = () => {
  return [`/exam/exams/published`] as const;
};

export const getGetPublishedExamsQueryOptions = <
  TData = Awaited<ReturnType<typeof getPublishedExams>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getPublishedExams>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPublishedExamsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getPublishedExams>>
  > = ({ signal }) => getPublishedExams(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPublishedExams>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPublishedExamsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPublishedExams>>
>;
export type GetPublishedExamsQueryError = unknown;

export function useGetPublishedExams<
  TData = Awaited<ReturnType<typeof getPublishedExams>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPublishedExams>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPublishedExams>>,
          TError,
          Awaited<ReturnType<typeof getPublishedExams>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPublishedExams<
  TData = Awaited<ReturnType<typeof getPublishedExams>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPublishedExams>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPublishedExams>>,
          TError,
          Awaited<ReturnType<typeof getPublishedExams>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPublishedExams<
  TData = Awaited<ReturnType<typeof getPublishedExams>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPublishedExams>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetPublishedExams<
  TData = Awaited<ReturnType<typeof getPublishedExams>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPublishedExams>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetPublishedExamsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getPopularExams = (
  params?: GetPopularExamsParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ExamDto[]>(
    { url: `/exam/exams/popular`, method: "GET", params, signal },
    options,
  );
};

export const getGetPopularExamsQueryKey = (params?: GetPopularExamsParams) => {
  return [`/exam/exams/popular`, ...(params ? [params] : [])] as const;
};

export const getGetPopularExamsQueryOptions = <
  TData = Awaited<ReturnType<typeof getPopularExams>>,
  TError = unknown,
>(
  params?: GetPopularExamsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPopularExams>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPopularExamsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPopularExams>>> = ({
    signal,
  }) => getPopularExams(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPopularExams>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPopularExamsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPopularExams>>
>;
export type GetPopularExamsQueryError = unknown;

export function useGetPopularExams<
  TData = Awaited<ReturnType<typeof getPopularExams>>,
  TError = unknown,
>(
  params: undefined | GetPopularExamsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPopularExams>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPopularExams>>,
          TError,
          Awaited<ReturnType<typeof getPopularExams>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPopularExams<
  TData = Awaited<ReturnType<typeof getPopularExams>>,
  TError = unknown,
>(
  params?: GetPopularExamsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPopularExams>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPopularExams>>,
          TError,
          Awaited<ReturnType<typeof getPopularExams>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPopularExams<
  TData = Awaited<ReturnType<typeof getPopularExams>>,
  TError = unknown,
>(
  params?: GetPopularExamsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPopularExams>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetPopularExams<
  TData = Awaited<ReturnType<typeof getPopularExams>>,
  TError = unknown,
>(
  params?: GetPopularExamsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPopularExams>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetPopularExamsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const findByCode = (
  params: FindByCodeParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ExamDto>(
    { url: `/exam/exams/find-by-code`, method: "GET", params, signal },
    options,
  );
};

export const getFindByCodeQueryKey = (params?: FindByCodeParams) => {
  return [`/exam/exams/find-by-code`, ...(params ? [params] : [])] as const;
};

export const getFindByCodeQueryOptions = <
  TData = Awaited<ReturnType<typeof findByCode>>,
  TError = unknown,
>(
  params: FindByCodeParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findByCode>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFindByCodeQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findByCode>>> = ({
    signal,
  }) => findByCode(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findByCode>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type FindByCodeQueryResult = NonNullable<
  Awaited<ReturnType<typeof findByCode>>
>;
export type FindByCodeQueryError = unknown;

export function useFindByCode<
  TData = Awaited<ReturnType<typeof findByCode>>,
  TError = unknown,
>(
  params: FindByCodeParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findByCode>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findByCode>>,
          TError,
          Awaited<ReturnType<typeof findByCode>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFindByCode<
  TData = Awaited<ReturnType<typeof findByCode>>,
  TError = unknown,
>(
  params: FindByCodeParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findByCode>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findByCode>>,
          TError,
          Awaited<ReturnType<typeof findByCode>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFindByCode<
  TData = Awaited<ReturnType<typeof findByCode>>,
  TError = unknown,
>(
  params: FindByCodeParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findByCode>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useFindByCode<
  TData = Awaited<ReturnType<typeof findByCode>>,
  TError = unknown,
>(
  params: FindByCodeParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findByCode>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getFindByCodeQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const existsByName = (
  params: ExistsByNameParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<boolean>(
    { url: `/exam/exams/exists-by-name`, method: "GET", params, signal },
    options,
  );
};

export const getExistsByNameQueryKey = (params?: ExistsByNameParams) => {
  return [`/exam/exams/exists-by-name`, ...(params ? [params] : [])] as const;
};

export const getExistsByNameQueryOptions = <
  TData = Awaited<ReturnType<typeof existsByName>>,
  TError = unknown,
>(
  params: ExistsByNameParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof existsByName>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getExistsByNameQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof existsByName>>> = ({
    signal,
  }) => existsByName(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof existsByName>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ExistsByNameQueryResult = NonNullable<
  Awaited<ReturnType<typeof existsByName>>
>;
export type ExistsByNameQueryError = unknown;

export function useExistsByName<
  TData = Awaited<ReturnType<typeof existsByName>>,
  TError = unknown,
>(
  params: ExistsByNameParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof existsByName>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof existsByName>>,
          TError,
          Awaited<ReturnType<typeof existsByName>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useExistsByName<
  TData = Awaited<ReturnType<typeof existsByName>>,
  TError = unknown,
>(
  params: ExistsByNameParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof existsByName>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof existsByName>>,
          TError,
          Awaited<ReturnType<typeof existsByName>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useExistsByName<
  TData = Awaited<ReturnType<typeof existsByName>>,
  TError = unknown,
>(
  params: ExistsByNameParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof existsByName>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useExistsByName<
  TData = Awaited<ReturnType<typeof existsByName>>,
  TError = unknown,
>(
  params: ExistsByNameParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof existsByName>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getExistsByNameQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const existsByCode = (
  params: ExistsByCodeParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<boolean>(
    { url: `/exam/exams/exists-by-code`, method: "GET", params, signal },
    options,
  );
};

export const getExistsByCodeQueryKey = (params?: ExistsByCodeParams) => {
  return [`/exam/exams/exists-by-code`, ...(params ? [params] : [])] as const;
};

export const getExistsByCodeQueryOptions = <
  TData = Awaited<ReturnType<typeof existsByCode>>,
  TError = unknown,
>(
  params: ExistsByCodeParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof existsByCode>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getExistsByCodeQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof existsByCode>>> = ({
    signal,
  }) => existsByCode(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof existsByCode>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ExistsByCodeQueryResult = NonNullable<
  Awaited<ReturnType<typeof existsByCode>>
>;
export type ExistsByCodeQueryError = unknown;

export function useExistsByCode<
  TData = Awaited<ReturnType<typeof existsByCode>>,
  TError = unknown,
>(
  params: ExistsByCodeParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof existsByCode>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof existsByCode>>,
          TError,
          Awaited<ReturnType<typeof existsByCode>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useExistsByCode<
  TData = Awaited<ReturnType<typeof existsByCode>>,
  TError = unknown,
>(
  params: ExistsByCodeParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof existsByCode>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof existsByCode>>,
          TError,
          Awaited<ReturnType<typeof existsByCode>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useExistsByCode<
  TData = Awaited<ReturnType<typeof existsByCode>>,
  TError = unknown,
>(
  params: ExistsByCodeParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof existsByCode>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useExistsByCode<
  TData = Awaited<ReturnType<typeof existsByCode>>,
  TError = unknown,
>(
  params: ExistsByCodeParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof existsByCode>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getExistsByCodeQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getDraftExams = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ExamDto[]>(
    { url: `/exam/exams/drafts`, method: "GET", signal },
    options,
  );
};

export const getGetDraftExamsQueryKey = () => {
  return [`/exam/exams/drafts`] as const;
};

export const getGetDraftExamsQueryOptions = <
  TData = Awaited<ReturnType<typeof getDraftExams>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getDraftExams>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDraftExamsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDraftExams>>> = ({
    signal,
  }) => getDraftExams(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getDraftExams>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetDraftExamsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDraftExams>>
>;
export type GetDraftExamsQueryError = unknown;

export function useGetDraftExams<
  TData = Awaited<ReturnType<typeof getDraftExams>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getDraftExams>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDraftExams>>,
          TError,
          Awaited<ReturnType<typeof getDraftExams>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetDraftExams<
  TData = Awaited<ReturnType<typeof getDraftExams>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getDraftExams>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDraftExams>>,
          TError,
          Awaited<ReturnType<typeof getDraftExams>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetDraftExams<
  TData = Awaited<ReturnType<typeof getDraftExams>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getDraftExams>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetDraftExams<
  TData = Awaited<ReturnType<typeof getDraftExams>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getDraftExams>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetDraftExamsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getExamsByLevel = (
  level: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ExamDto[]>(
    { url: `/exam/exams/by-level/${level}`, method: "GET", signal },
    options,
  );
};

export const getGetExamsByLevelQueryKey = (level?: string) => {
  return [`/exam/exams/by-level/${level}`] as const;
};

export const getGetExamsByLevelQueryOptions = <
  TData = Awaited<ReturnType<typeof getExamsByLevel>>,
  TError = unknown,
>(
  level: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamsByLevel>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetExamsByLevelQueryKey(level);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getExamsByLevel>>> = ({
    signal,
  }) => getExamsByLevel(level, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!level,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getExamsByLevel>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetExamsByLevelQueryResult = NonNullable<
  Awaited<ReturnType<typeof getExamsByLevel>>
>;
export type GetExamsByLevelQueryError = unknown;

export function useGetExamsByLevel<
  TData = Awaited<ReturnType<typeof getExamsByLevel>>,
  TError = unknown,
>(
  level: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamsByLevel>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExamsByLevel>>,
          TError,
          Awaited<ReturnType<typeof getExamsByLevel>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExamsByLevel<
  TData = Awaited<ReturnType<typeof getExamsByLevel>>,
  TError = unknown,
>(
  level: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamsByLevel>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExamsByLevel>>,
          TError,
          Awaited<ReturnType<typeof getExamsByLevel>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExamsByLevel<
  TData = Awaited<ReturnType<typeof getExamsByLevel>>,
  TError = unknown,
>(
  level: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamsByLevel>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetExamsByLevel<
  TData = Awaited<ReturnType<typeof getExamsByLevel>>,
  TError = unknown,
>(
  level: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamsByLevel>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetExamsByLevelQueryOptions(level, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getExamsByCreator = (
  userId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ExamDto[]>(
    { url: `/exam/exams/by-creator/${userId}`, method: "GET", signal },
    options,
  );
};

export const getGetExamsByCreatorQueryKey = (userId?: string) => {
  return [`/exam/exams/by-creator/${userId}`] as const;
};

export const getGetExamsByCreatorQueryOptions = <
  TData = Awaited<ReturnType<typeof getExamsByCreator>>,
  TError = unknown,
>(
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamsByCreator>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetExamsByCreatorQueryKey(userId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getExamsByCreator>>
  > = ({ signal }) => getExamsByCreator(userId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!userId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getExamsByCreator>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetExamsByCreatorQueryResult = NonNullable<
  Awaited<ReturnType<typeof getExamsByCreator>>
>;
export type GetExamsByCreatorQueryError = unknown;

export function useGetExamsByCreator<
  TData = Awaited<ReturnType<typeof getExamsByCreator>>,
  TError = unknown,
>(
  userId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamsByCreator>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExamsByCreator>>,
          TError,
          Awaited<ReturnType<typeof getExamsByCreator>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExamsByCreator<
  TData = Awaited<ReturnType<typeof getExamsByCreator>>,
  TError = unknown,
>(
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamsByCreator>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExamsByCreator>>,
          TError,
          Awaited<ReturnType<typeof getExamsByCreator>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExamsByCreator<
  TData = Awaited<ReturnType<typeof getExamsByCreator>>,
  TError = unknown,
>(
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamsByCreator>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetExamsByCreator<
  TData = Awaited<ReturnType<typeof getExamsByCreator>>,
  TError = unknown,
>(
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamsByCreator>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetExamsByCreatorQueryOptions(userId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getExamsByCategory = (
  category: "IELTS" | "TOEFL",
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ExamDto[]>(
    { url: `/exam/exams/by-category/${category}`, method: "GET", signal },
    options,
  );
};

export const getGetExamsByCategoryQueryKey = (category?: "IELTS" | "TOEFL") => {
  return [`/exam/exams/by-category/${category}`] as const;
};

export const getGetExamsByCategoryQueryOptions = <
  TData = Awaited<ReturnType<typeof getExamsByCategory>>,
  TError = unknown,
>(
  category: "IELTS" | "TOEFL",
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamsByCategory>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetExamsByCategoryQueryKey(category);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getExamsByCategory>>
  > = ({ signal }) => getExamsByCategory(category, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!category,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getExamsByCategory>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetExamsByCategoryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getExamsByCategory>>
>;
export type GetExamsByCategoryQueryError = unknown;

export function useGetExamsByCategory<
  TData = Awaited<ReturnType<typeof getExamsByCategory>>,
  TError = unknown,
>(
  category: "IELTS" | "TOEFL",
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamsByCategory>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExamsByCategory>>,
          TError,
          Awaited<ReturnType<typeof getExamsByCategory>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExamsByCategory<
  TData = Awaited<ReturnType<typeof getExamsByCategory>>,
  TError = unknown,
>(
  category: "IELTS" | "TOEFL",
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamsByCategory>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExamsByCategory>>,
          TError,
          Awaited<ReturnType<typeof getExamsByCategory>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExamsByCategory<
  TData = Awaited<ReturnType<typeof getExamsByCategory>>,
  TError = unknown,
>(
  category: "IELTS" | "TOEFL",
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamsByCategory>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetExamsByCategory<
  TData = Awaited<ReturnType<typeof getExamsByCategory>>,
  TError = unknown,
>(
  category: "IELTS" | "TOEFL",
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamsByCategory>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetExamsByCategoryQueryOptions(category, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const softDeleteExam = (
  examId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<string>(
    { url: `/exam/exams/${examId}/soft-delete`, method: "DELETE" },
    options,
  );
};

export const getSoftDeleteExamMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof softDeleteExam>>,
    TError,
    { examId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof softDeleteExam>>,
  TError,
  { examId: string },
  TContext
> => {
  const mutationKey = ["softDeleteExam"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof softDeleteExam>>,
    { examId: string }
  > = (props) => {
    const { examId } = props ?? {};

    return softDeleteExam(examId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type SoftDeleteExamMutationResult = NonNullable<
  Awaited<ReturnType<typeof softDeleteExam>>
>;

export type SoftDeleteExamMutationError = unknown;

export const useSoftDeleteExam = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof softDeleteExam>>,
      TError,
      { examId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof softDeleteExam>>,
  TError,
  { examId: string },
  TContext
> => {
  const mutationOptions = getSoftDeleteExamMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const removeQuestionFromExam = (
  examId: string,
  questionId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<ExamDto>(
    { url: `/exam/exams/${examId}/questions/${questionId}`, method: "DELETE" },
    options,
  );
};

export const getRemoveQuestionFromExamMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeQuestionFromExam>>,
    TError,
    { examId: string; questionId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeQuestionFromExam>>,
  TError,
  { examId: string; questionId: string },
  TContext
> => {
  const mutationKey = ["removeQuestionFromExam"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeQuestionFromExam>>,
    { examId: string; questionId: string }
  > = (props) => {
    const { examId, questionId } = props ?? {};

    return removeQuestionFromExam(examId, questionId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveQuestionFromExamMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeQuestionFromExam>>
>;

export type RemoveQuestionFromExamMutationError = unknown;

export const useRemoveQuestionFromExam = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof removeQuestionFromExam>>,
      TError,
      { examId: string; questionId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof removeQuestionFromExam>>,
  TError,
  { examId: string; questionId: string },
  TContext
> => {
  const mutationOptions = getRemoveQuestionFromExamMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const removeQuestionsWithTemplate = (
  examId: string,
  templateId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<ExamDto>(
    {
      url: `/exam/exams/${examId}/questions-with-template/${templateId}`,
      method: "DELETE",
    },
    options,
  );
};

export const getRemoveQuestionsWithTemplateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeQuestionsWithTemplate>>,
    TError,
    { examId: string; templateId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeQuestionsWithTemplate>>,
  TError,
  { examId: string; templateId: string },
  TContext
> => {
  const mutationKey = ["removeQuestionsWithTemplate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeQuestionsWithTemplate>>,
    { examId: string; templateId: string }
  > = (props) => {
    const { examId, templateId } = props ?? {};

    return removeQuestionsWithTemplate(examId, templateId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveQuestionsWithTemplateMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeQuestionsWithTemplate>>
>;

export type RemoveQuestionsWithTemplateMutationError = unknown;

export const useRemoveQuestionsWithTemplate = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof removeQuestionsWithTemplate>>,
      TError,
      { examId: string; templateId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof removeQuestionsWithTemplate>>,
  TError,
  { examId: string; templateId: string },
  TContext
> => {
  const mutationOptions =
    getRemoveQuestionsWithTemplateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const deleteMultipleExams = (
  deleteMultipleExamsBody: string[],
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<string>(
    {
      url: `/exam/exams/bulk-delete`,
      method: "DELETE",
      headers: { "Content-Type": "application/json" },
      data: deleteMultipleExamsBody,
    },
    options,
  );
};

export const getDeleteMultipleExamsMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteMultipleExams>>,
    TError,
    { data: string[] },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteMultipleExams>>,
  TError,
  { data: string[] },
  TContext
> => {
  const mutationKey = ["deleteMultipleExams"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteMultipleExams>>,
    { data: string[] }
  > = (props) => {
    const { data } = props ?? {};

    return deleteMultipleExams(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteMultipleExamsMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteMultipleExams>>
>;
export type DeleteMultipleExamsMutationBody = string[];
export type DeleteMultipleExamsMutationError = unknown;

export const useDeleteMultipleExams = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteMultipleExams>>,
      TError,
      { data: string[] },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteMultipleExams>>,
  TError,
  { data: string[] },
  TContext
> => {
  const mutationOptions = getDeleteMultipleExamsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
