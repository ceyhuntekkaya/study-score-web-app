/**
 * Generated by orval v7.17.0 üç∫
 * Do not edit manually.
 * OpenAPI definition
 * OpenAPI spec version: v0
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import type {
  AddTagParams,
  BulkUpdatePointsParams,
  BulkUpdateTimeLimitParams,
  CreateQuestionFromTemplateParams,
  CreateQuestionsFromTemplatesParams,
  DuplicateQuestionsParams,
  ExamQuestionDto,
  GetMostRecentlyUpdatedParams,
  GetQuestionSkillDistribution200,
  GetQuestionTypeDistribution200,
  GetQuestionsPaginatedParams,
  GetRecentQuestionsParams,
  LinkTemplateParams,
  PageExamQuestionDto,
  QuestionAnalyticsDto,
  QuestionFilterDto,
  QuestionStatisticsDto,
  RemoveTagParams,
  SearchQuestionsParams,
  ShuffleQuestionOptionsParams,
  UpdatePointsParams,
  UpdateQuestionOrderParams,
  UpdateTemplateReferencesParams,
  UpdateTimeLimitParams,
} from "../openAPIDefinition.schemas";

import { customInstance } from "../../../lib/api-client";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

export const getExamQuestionById = (
  questionId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ExamQuestionDto>(
    { url: `/exam/exam-questions/${questionId}`, method: "GET", signal },
    options,
  );
};

export const getGetExamQuestionByIdQueryKey = (questionId?: string) => {
  return [`/exam/exam-questions/${questionId}`] as const;
};

export const getGetExamQuestionByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getExamQuestionById>>,
  TError = unknown,
>(
  questionId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamQuestionById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetExamQuestionByIdQueryKey(questionId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getExamQuestionById>>
  > = ({ signal }) => getExamQuestionById(questionId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!questionId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getExamQuestionById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetExamQuestionByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getExamQuestionById>>
>;
export type GetExamQuestionByIdQueryError = unknown;

export function useGetExamQuestionById<
  TData = Awaited<ReturnType<typeof getExamQuestionById>>,
  TError = unknown,
>(
  questionId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamQuestionById>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExamQuestionById>>,
          TError,
          Awaited<ReturnType<typeof getExamQuestionById>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExamQuestionById<
  TData = Awaited<ReturnType<typeof getExamQuestionById>>,
  TError = unknown,
>(
  questionId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamQuestionById>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExamQuestionById>>,
          TError,
          Awaited<ReturnType<typeof getExamQuestionById>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExamQuestionById<
  TData = Awaited<ReturnType<typeof getExamQuestionById>>,
  TError = unknown,
>(
  questionId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamQuestionById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetExamQuestionById<
  TData = Awaited<ReturnType<typeof getExamQuestionById>>,
  TError = unknown,
>(
  questionId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamQuestionById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetExamQuestionByIdQueryOptions(questionId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const updateExamQuestion = (
  questionId: string,
  examQuestionDto: ExamQuestionDto,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<ExamQuestionDto>(
    {
      url: `/exam/exam-questions/${questionId}`,
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      data: examQuestionDto,
    },
    options,
  );
};

export const getUpdateExamQuestionMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateExamQuestion>>,
    TError,
    { questionId: string; data: ExamQuestionDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateExamQuestion>>,
  TError,
  { questionId: string; data: ExamQuestionDto },
  TContext
> => {
  const mutationKey = ["updateExamQuestion"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateExamQuestion>>,
    { questionId: string; data: ExamQuestionDto }
  > = (props) => {
    const { questionId, data } = props ?? {};

    return updateExamQuestion(questionId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateExamQuestionMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateExamQuestion>>
>;
export type UpdateExamQuestionMutationBody = ExamQuestionDto;
export type UpdateExamQuestionMutationError = unknown;

export const useUpdateExamQuestion = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateExamQuestion>>,
      TError,
      { questionId: string; data: ExamQuestionDto },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateExamQuestion>>,
  TError,
  { questionId: string; data: ExamQuestionDto },
  TContext
> => {
  const mutationOptions = getUpdateExamQuestionMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const deleteExamQuestion = (
  questionId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<string>(
    { url: `/exam/exam-questions/${questionId}`, method: "DELETE" },
    options,
  );
};

export const getDeleteExamQuestionMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteExamQuestion>>,
    TError,
    { questionId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteExamQuestion>>,
  TError,
  { questionId: string },
  TContext
> => {
  const mutationKey = ["deleteExamQuestion"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteExamQuestion>>,
    { questionId: string }
  > = (props) => {
    const { questionId } = props ?? {};

    return deleteExamQuestion(questionId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteExamQuestionMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteExamQuestion>>
>;

export type DeleteExamQuestionMutationError = unknown;

export const useDeleteExamQuestion = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteExamQuestion>>,
      TError,
      { questionId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteExamQuestion>>,
  TError,
  { questionId: string },
  TContext
> => {
  const mutationOptions = getDeleteExamQuestionMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const unlinkTemplate = (
  questionId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<ExamQuestionDto>(
    {
      url: `/exam/exam-questions/${questionId}/unlink-template`,
      method: "PUT",
    },
    options,
  );
};

export const getUnlinkTemplateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof unlinkTemplate>>,
    TError,
    { questionId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof unlinkTemplate>>,
  TError,
  { questionId: string },
  TContext
> => {
  const mutationKey = ["unlinkTemplate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof unlinkTemplate>>,
    { questionId: string }
  > = (props) => {
    const { questionId } = props ?? {};

    return unlinkTemplate(questionId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UnlinkTemplateMutationResult = NonNullable<
  Awaited<ReturnType<typeof unlinkTemplate>>
>;

export type UnlinkTemplateMutationError = unknown;

export const useUnlinkTemplate = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof unlinkTemplate>>,
      TError,
      { questionId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof unlinkTemplate>>,
  TError,
  { questionId: string },
  TContext
> => {
  const mutationOptions = getUnlinkTemplateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const toggleQuestionStatus = (
  questionId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<ExamQuestionDto>(
    { url: `/exam/exam-questions/${questionId}/toggle-status`, method: "PUT" },
    options,
  );
};

export const getToggleQuestionStatusMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof toggleQuestionStatus>>,
    TError,
    { questionId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof toggleQuestionStatus>>,
  TError,
  { questionId: string },
  TContext
> => {
  const mutationKey = ["toggleQuestionStatus"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof toggleQuestionStatus>>,
    { questionId: string }
  > = (props) => {
    const { questionId } = props ?? {};

    return toggleQuestionStatus(questionId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ToggleQuestionStatusMutationResult = NonNullable<
  Awaited<ReturnType<typeof toggleQuestionStatus>>
>;

export type ToggleQuestionStatusMutationError = unknown;

export const useToggleQuestionStatus = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof toggleQuestionStatus>>,
      TError,
      { questionId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof toggleQuestionStatus>>,
  TError,
  { questionId: string },
  TContext
> => {
  const mutationOptions = getToggleQuestionStatusMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const updateTimeLimit = (
  questionId: string,
  params: UpdateTimeLimitParams,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<ExamQuestionDto>(
    {
      url: `/exam/exam-questions/${questionId}/time-limit`,
      method: "PUT",
      params,
    },
    options,
  );
};

export const getUpdateTimeLimitMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateTimeLimit>>,
    TError,
    { questionId: string; params: UpdateTimeLimitParams },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateTimeLimit>>,
  TError,
  { questionId: string; params: UpdateTimeLimitParams },
  TContext
> => {
  const mutationKey = ["updateTimeLimit"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateTimeLimit>>,
    { questionId: string; params: UpdateTimeLimitParams }
  > = (props) => {
    const { questionId, params } = props ?? {};

    return updateTimeLimit(questionId, params, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateTimeLimitMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateTimeLimit>>
>;

export type UpdateTimeLimitMutationError = unknown;

export const useUpdateTimeLimit = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateTimeLimit>>,
      TError,
      { questionId: string; params: UpdateTimeLimitParams },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateTimeLimit>>,
  TError,
  { questionId: string; params: UpdateTimeLimitParams },
  TContext
> => {
  const mutationOptions = getUpdateTimeLimitMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const shuffleQuestionOptions = (
  questionId: string,
  params: ShuffleQuestionOptionsParams,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<ExamQuestionDto>(
    {
      url: `/exam/exam-questions/${questionId}/shuffle-options`,
      method: "PUT",
      params,
    },
    options,
  );
};

export const getShuffleQuestionOptionsMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof shuffleQuestionOptions>>,
    TError,
    { questionId: string; params: ShuffleQuestionOptionsParams },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof shuffleQuestionOptions>>,
  TError,
  { questionId: string; params: ShuffleQuestionOptionsParams },
  TContext
> => {
  const mutationKey = ["shuffleQuestionOptions"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof shuffleQuestionOptions>>,
    { questionId: string; params: ShuffleQuestionOptionsParams }
  > = (props) => {
    const { questionId, params } = props ?? {};

    return shuffleQuestionOptions(questionId, params, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ShuffleQuestionOptionsMutationResult = NonNullable<
  Awaited<ReturnType<typeof shuffleQuestionOptions>>
>;

export type ShuffleQuestionOptionsMutationError = unknown;

export const useShuffleQuestionOptions = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof shuffleQuestionOptions>>,
      TError,
      { questionId: string; params: ShuffleQuestionOptionsParams },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof shuffleQuestionOptions>>,
  TError,
  { questionId: string; params: ShuffleQuestionOptionsParams },
  TContext
> => {
  const mutationOptions = getShuffleQuestionOptionsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const removeTag = (
  questionId: string,
  params: RemoveTagParams,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<ExamQuestionDto>(
    {
      url: `/exam/exam-questions/${questionId}/remove-tag`,
      method: "PUT",
      params,
    },
    options,
  );
};

export const getRemoveTagMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeTag>>,
    TError,
    { questionId: string; params: RemoveTagParams },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeTag>>,
  TError,
  { questionId: string; params: RemoveTagParams },
  TContext
> => {
  const mutationKey = ["removeTag"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeTag>>,
    { questionId: string; params: RemoveTagParams }
  > = (props) => {
    const { questionId, params } = props ?? {};

    return removeTag(questionId, params, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveTagMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeTag>>
>;

export type RemoveTagMutationError = unknown;

export const useRemoveTag = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof removeTag>>,
      TError,
      { questionId: string; params: RemoveTagParams },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof removeTag>>,
  TError,
  { questionId: string; params: RemoveTagParams },
  TContext
> => {
  const mutationOptions = getRemoveTagMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const updatePoints = (
  questionId: string,
  params: UpdatePointsParams,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<ExamQuestionDto>(
    { url: `/exam/exam-questions/${questionId}/points`, method: "PUT", params },
    options,
  );
};

export const getUpdatePointsMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updatePoints>>,
    TError,
    { questionId: string; params: UpdatePointsParams },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updatePoints>>,
  TError,
  { questionId: string; params: UpdatePointsParams },
  TContext
> => {
  const mutationKey = ["updatePoints"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updatePoints>>,
    { questionId: string; params: UpdatePointsParams }
  > = (props) => {
    const { questionId, params } = props ?? {};

    return updatePoints(questionId, params, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdatePointsMutationResult = NonNullable<
  Awaited<ReturnType<typeof updatePoints>>
>;

export type UpdatePointsMutationError = unknown;

export const useUpdatePoints = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updatePoints>>,
      TError,
      { questionId: string; params: UpdatePointsParams },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updatePoints>>,
  TError,
  { questionId: string; params: UpdatePointsParams },
  TContext
> => {
  const mutationOptions = getUpdatePointsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const updateQuestionOrder = (
  questionId: string,
  params: UpdateQuestionOrderParams,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<ExamQuestionDto>(
    { url: `/exam/exam-questions/${questionId}/order`, method: "PUT", params },
    options,
  );
};

export const getUpdateQuestionOrderMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateQuestionOrder>>,
    TError,
    { questionId: string; params: UpdateQuestionOrderParams },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateQuestionOrder>>,
  TError,
  { questionId: string; params: UpdateQuestionOrderParams },
  TContext
> => {
  const mutationKey = ["updateQuestionOrder"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateQuestionOrder>>,
    { questionId: string; params: UpdateQuestionOrderParams }
  > = (props) => {
    const { questionId, params } = props ?? {};

    return updateQuestionOrder(questionId, params, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateQuestionOrderMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateQuestionOrder>>
>;

export type UpdateQuestionOrderMutationError = unknown;

export const useUpdateQuestionOrder = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateQuestionOrder>>,
      TError,
      { questionId: string; params: UpdateQuestionOrderParams },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateQuestionOrder>>,
  TError,
  { questionId: string; params: UpdateQuestionOrderParams },
  TContext
> => {
  const mutationOptions = getUpdateQuestionOrderMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const linkTemplate = (
  questionId: string,
  params: LinkTemplateParams,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<ExamQuestionDto>(
    {
      url: `/exam/exam-questions/${questionId}/link-template`,
      method: "PUT",
      params,
    },
    options,
  );
};

export const getLinkTemplateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof linkTemplate>>,
    TError,
    { questionId: string; params: LinkTemplateParams },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof linkTemplate>>,
  TError,
  { questionId: string; params: LinkTemplateParams },
  TContext
> => {
  const mutationKey = ["linkTemplate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof linkTemplate>>,
    { questionId: string; params: LinkTemplateParams }
  > = (props) => {
    const { questionId, params } = props ?? {};

    return linkTemplate(questionId, params, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type LinkTemplateMutationResult = NonNullable<
  Awaited<ReturnType<typeof linkTemplate>>
>;

export type LinkTemplateMutationError = unknown;

export const useLinkTemplate = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof linkTemplate>>,
      TError,
      { questionId: string; params: LinkTemplateParams },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof linkTemplate>>,
  TError,
  { questionId: string; params: LinkTemplateParams },
  TContext
> => {
  const mutationOptions = getLinkTemplateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const setCurriculumContent = (
  questionId: string,
  setCurriculumContentBody: string[],
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<ExamQuestionDto>(
    {
      url: `/exam/exam-questions/${questionId}/curriculum-content`,
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      data: setCurriculumContentBody,
    },
    options,
  );
};

export const getSetCurriculumContentMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof setCurriculumContent>>,
    TError,
    { questionId: string; data: string[] },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof setCurriculumContent>>,
  TError,
  { questionId: string; data: string[] },
  TContext
> => {
  const mutationKey = ["setCurriculumContent"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof setCurriculumContent>>,
    { questionId: string; data: string[] }
  > = (props) => {
    const { questionId, data } = props ?? {};

    return setCurriculumContent(questionId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type SetCurriculumContentMutationResult = NonNullable<
  Awaited<ReturnType<typeof setCurriculumContent>>
>;
export type SetCurriculumContentMutationBody = string[];
export type SetCurriculumContentMutationError = unknown;

export const useSetCurriculumContent = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof setCurriculumContent>>,
      TError,
      { questionId: string; data: string[] },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof setCurriculumContent>>,
  TError,
  { questionId: string; data: string[] },
  TContext
> => {
  const mutationOptions = getSetCurriculumContentMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const addTag = (
  questionId: string,
  params: AddTagParams,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<ExamQuestionDto>(
    {
      url: `/exam/exam-questions/${questionId}/add-tag`,
      method: "PUT",
      params,
    },
    options,
  );
};

export const getAddTagMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addTag>>,
    TError,
    { questionId: string; params: AddTagParams },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof addTag>>,
  TError,
  { questionId: string; params: AddTagParams },
  TContext
> => {
  const mutationKey = ["addTag"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addTag>>,
    { questionId: string; params: AddTagParams }
  > = (props) => {
    const { questionId, params } = props ?? {};

    return addTag(questionId, params, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AddTagMutationResult = NonNullable<
  Awaited<ReturnType<typeof addTag>>
>;

export type AddTagMutationError = unknown;

export const useAddTag = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof addTag>>,
      TError,
      { questionId: string; params: AddTagParams },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof addTag>>,
  TError,
  { questionId: string; params: AddTagParams },
  TContext
> => {
  const mutationOptions = getAddTagMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const reorderQuestionsByPart = (
  partId: string,
  reorderQuestionsByPartBody: string[],
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<ExamQuestionDto[]>(
    {
      url: `/exam/exam-questions/${partId}/reorder-by-part`,
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      data: reorderQuestionsByPartBody,
    },
    options,
  );
};

export const getReorderQuestionsByPartMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof reorderQuestionsByPart>>,
    TError,
    { partId: string; data: string[] },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof reorderQuestionsByPart>>,
  TError,
  { partId: string; data: string[] },
  TContext
> => {
  const mutationKey = ["reorderQuestionsByPart"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof reorderQuestionsByPart>>,
    { partId: string; data: string[] }
  > = (props) => {
    const { partId, data } = props ?? {};

    return reorderQuestionsByPart(partId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ReorderQuestionsByPartMutationResult = NonNullable<
  Awaited<ReturnType<typeof reorderQuestionsByPart>>
>;
export type ReorderQuestionsByPartMutationBody = string[];
export type ReorderQuestionsByPartMutationError = unknown;

export const useReorderQuestionsByPart = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof reorderQuestionsByPart>>,
      TError,
      { partId: string; data: string[] },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof reorderQuestionsByPart>>,
  TError,
  { partId: string; data: string[] },
  TContext
> => {
  const mutationOptions = getReorderQuestionsByPartMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const reorderQuestions1 = (
  examId: string,
  reorderQuestions1Body: string[],
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<ExamQuestionDto[]>(
    {
      url: `/exam/exam-questions/${examId}/reorder`,
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      data: reorderQuestions1Body,
    },
    options,
  );
};

export const getReorderQuestions1MutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof reorderQuestions1>>,
    TError,
    { examId: string; data: string[] },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof reorderQuestions1>>,
  TError,
  { examId: string; data: string[] },
  TContext
> => {
  const mutationKey = ["reorderQuestions1"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof reorderQuestions1>>,
    { examId: string; data: string[] }
  > = (props) => {
    const { examId, data } = props ?? {};

    return reorderQuestions1(examId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ReorderQuestions1MutationResult = NonNullable<
  Awaited<ReturnType<typeof reorderQuestions1>>
>;
export type ReorderQuestions1MutationBody = string[];
export type ReorderQuestions1MutationError = unknown;

export const useReorderQuestions1 = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof reorderQuestions1>>,
      TError,
      { examId: string; data: string[] },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof reorderQuestions1>>,
  TError,
  { examId: string; data: string[] },
  TContext
> => {
  const mutationOptions = getReorderQuestions1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const updateTemplateReferences = (
  params: UpdateTemplateReferencesParams,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<string>(
    {
      url: `/exam/exam-questions/update-template-references`,
      method: "PUT",
      params,
    },
    options,
  );
};

export const getUpdateTemplateReferencesMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateTemplateReferences>>,
    TError,
    { params: UpdateTemplateReferencesParams },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateTemplateReferences>>,
  TError,
  { params: UpdateTemplateReferencesParams },
  TContext
> => {
  const mutationKey = ["updateTemplateReferences"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateTemplateReferences>>,
    { params: UpdateTemplateReferencesParams }
  > = (props) => {
    const { params } = props ?? {};

    return updateTemplateReferences(params, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateTemplateReferencesMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateTemplateReferences>>
>;

export type UpdateTemplateReferencesMutationError = unknown;

export const useUpdateTemplateReferences = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateTemplateReferences>>,
      TError,
      { params: UpdateTemplateReferencesParams },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateTemplateReferences>>,
  TError,
  { params: UpdateTemplateReferencesParams },
  TContext
> => {
  const mutationOptions = getUpdateTemplateReferencesMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const bulkUpdateTimeLimit = (
  bulkUpdateTimeLimitBody: string[],
  params: BulkUpdateTimeLimitParams,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<ExamQuestionDto[]>(
    {
      url: `/exam/exam-questions/bulk-update-time-limit`,
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      data: bulkUpdateTimeLimitBody,
      params,
    },
    options,
  );
};

export const getBulkUpdateTimeLimitMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof bulkUpdateTimeLimit>>,
    TError,
    { data: string[]; params: BulkUpdateTimeLimitParams },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof bulkUpdateTimeLimit>>,
  TError,
  { data: string[]; params: BulkUpdateTimeLimitParams },
  TContext
> => {
  const mutationKey = ["bulkUpdateTimeLimit"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof bulkUpdateTimeLimit>>,
    { data: string[]; params: BulkUpdateTimeLimitParams }
  > = (props) => {
    const { data, params } = props ?? {};

    return bulkUpdateTimeLimit(data, params, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type BulkUpdateTimeLimitMutationResult = NonNullable<
  Awaited<ReturnType<typeof bulkUpdateTimeLimit>>
>;
export type BulkUpdateTimeLimitMutationBody = string[];
export type BulkUpdateTimeLimitMutationError = unknown;

export const useBulkUpdateTimeLimit = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof bulkUpdateTimeLimit>>,
      TError,
      { data: string[]; params: BulkUpdateTimeLimitParams },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof bulkUpdateTimeLimit>>,
  TError,
  { data: string[]; params: BulkUpdateTimeLimitParams },
  TContext
> => {
  const mutationOptions = getBulkUpdateTimeLimitMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const bulkUpdatePoints = (
  bulkUpdatePointsBody: string[],
  params: BulkUpdatePointsParams,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<ExamQuestionDto[]>(
    {
      url: `/exam/exam-questions/bulk-update-points`,
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      data: bulkUpdatePointsBody,
      params,
    },
    options,
  );
};

export const getBulkUpdatePointsMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof bulkUpdatePoints>>,
    TError,
    { data: string[]; params: BulkUpdatePointsParams },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof bulkUpdatePoints>>,
  TError,
  { data: string[]; params: BulkUpdatePointsParams },
  TContext
> => {
  const mutationKey = ["bulkUpdatePoints"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof bulkUpdatePoints>>,
    { data: string[]; params: BulkUpdatePointsParams }
  > = (props) => {
    const { data, params } = props ?? {};

    return bulkUpdatePoints(data, params, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type BulkUpdatePointsMutationResult = NonNullable<
  Awaited<ReturnType<typeof bulkUpdatePoints>>
>;
export type BulkUpdatePointsMutationBody = string[];
export type BulkUpdatePointsMutationError = unknown;

export const useBulkUpdatePoints = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof bulkUpdatePoints>>,
      TError,
      { data: string[]; params: BulkUpdatePointsParams },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof bulkUpdatePoints>>,
  TError,
  { data: string[]; params: BulkUpdatePointsParams },
  TContext
> => {
  const mutationOptions = getBulkUpdatePointsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const createExamQuestion = (
  examQuestionDto: ExamQuestionDto,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ExamQuestionDto>(
    {
      url: `/exam/exam-questions`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: examQuestionDto,
      signal,
    },
    options,
  );
};

export const getCreateExamQuestionMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createExamQuestion>>,
    TError,
    { data: ExamQuestionDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createExamQuestion>>,
  TError,
  { data: ExamQuestionDto },
  TContext
> => {
  const mutationKey = ["createExamQuestion"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createExamQuestion>>,
    { data: ExamQuestionDto }
  > = (props) => {
    const { data } = props ?? {};

    return createExamQuestion(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateExamQuestionMutationResult = NonNullable<
  Awaited<ReturnType<typeof createExamQuestion>>
>;
export type CreateExamQuestionMutationBody = ExamQuestionDto;
export type CreateExamQuestionMutationError = unknown;

export const useCreateExamQuestion = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createExamQuestion>>,
      TError,
      { data: ExamQuestionDto },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createExamQuestion>>,
  TError,
  { data: ExamQuestionDto },
  TContext
> => {
  const mutationOptions = getCreateExamQuestionMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const getQuestionsWithTemplates = (
  getQuestionsWithTemplatesBody: string[],
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ExamQuestionDto[]>(
    {
      url: `/exam/exam-questions/with-templates`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: getQuestionsWithTemplatesBody,
      signal,
    },
    options,
  );
};

export const getGetQuestionsWithTemplatesMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof getQuestionsWithTemplates>>,
    TError,
    { data: string[] },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof getQuestionsWithTemplates>>,
  TError,
  { data: string[] },
  TContext
> => {
  const mutationKey = ["getQuestionsWithTemplates"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof getQuestionsWithTemplates>>,
    { data: string[] }
  > = (props) => {
    const { data } = props ?? {};

    return getQuestionsWithTemplates(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type GetQuestionsWithTemplatesMutationResult = NonNullable<
  Awaited<ReturnType<typeof getQuestionsWithTemplates>>
>;
export type GetQuestionsWithTemplatesMutationBody = string[];
export type GetQuestionsWithTemplatesMutationError = unknown;

export const useGetQuestionsWithTemplates = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof getQuestionsWithTemplates>>,
      TError,
      { data: string[] },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof getQuestionsWithTemplates>>,
  TError,
  { data: string[] },
  TContext
> => {
  const mutationOptions = getGetQuestionsWithTemplatesMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const createQuestionsFromTemplates = (
  createQuestionsFromTemplatesBody: string[],
  params?: CreateQuestionsFromTemplatesParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ExamQuestionDto[]>(
    {
      url: `/exam/exam-questions/from-templates`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: createQuestionsFromTemplatesBody,
      params,
      signal,
    },
    options,
  );
};

export const getCreateQuestionsFromTemplatesMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createQuestionsFromTemplates>>,
    TError,
    { data: string[]; params?: CreateQuestionsFromTemplatesParams },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createQuestionsFromTemplates>>,
  TError,
  { data: string[]; params?: CreateQuestionsFromTemplatesParams },
  TContext
> => {
  const mutationKey = ["createQuestionsFromTemplates"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createQuestionsFromTemplates>>,
    { data: string[]; params?: CreateQuestionsFromTemplatesParams }
  > = (props) => {
    const { data, params } = props ?? {};

    return createQuestionsFromTemplates(data, params, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateQuestionsFromTemplatesMutationResult = NonNullable<
  Awaited<ReturnType<typeof createQuestionsFromTemplates>>
>;
export type CreateQuestionsFromTemplatesMutationBody = string[];
export type CreateQuestionsFromTemplatesMutationError = unknown;

export const useCreateQuestionsFromTemplates = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createQuestionsFromTemplates>>,
      TError,
      { data: string[]; params?: CreateQuestionsFromTemplatesParams },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createQuestionsFromTemplates>>,
  TError,
  { data: string[]; params?: CreateQuestionsFromTemplatesParams },
  TContext
> => {
  const mutationOptions =
    getCreateQuestionsFromTemplatesMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const createQuestionFromTemplate = (
  params: CreateQuestionFromTemplateParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ExamQuestionDto>(
    {
      url: `/exam/exam-questions/from-template`,
      method: "POST",
      params,
      signal,
    },
    options,
  );
};

export const getCreateQuestionFromTemplateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createQuestionFromTemplate>>,
    TError,
    { params: CreateQuestionFromTemplateParams },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createQuestionFromTemplate>>,
  TError,
  { params: CreateQuestionFromTemplateParams },
  TContext
> => {
  const mutationKey = ["createQuestionFromTemplate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createQuestionFromTemplate>>,
    { params: CreateQuestionFromTemplateParams }
  > = (props) => {
    const { params } = props ?? {};

    return createQuestionFromTemplate(params, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateQuestionFromTemplateMutationResult = NonNullable<
  Awaited<ReturnType<typeof createQuestionFromTemplate>>
>;

export type CreateQuestionFromTemplateMutationError = unknown;

export const useCreateQuestionFromTemplate = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createQuestionFromTemplate>>,
      TError,
      { params: CreateQuestionFromTemplateParams },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createQuestionFromTemplate>>,
  TError,
  { params: CreateQuestionFromTemplateParams },
  TContext
> => {
  const mutationOptions = getCreateQuestionFromTemplateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const filterQuestions = (
  questionFilterDto: QuestionFilterDto,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ExamQuestionDto[]>(
    {
      url: `/exam/exam-questions/filter`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: questionFilterDto,
      signal,
    },
    options,
  );
};

export const getFilterQuestionsMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof filterQuestions>>,
    TError,
    { data: QuestionFilterDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof filterQuestions>>,
  TError,
  { data: QuestionFilterDto },
  TContext
> => {
  const mutationKey = ["filterQuestions"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof filterQuestions>>,
    { data: QuestionFilterDto }
  > = (props) => {
    const { data } = props ?? {};

    return filterQuestions(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type FilterQuestionsMutationResult = NonNullable<
  Awaited<ReturnType<typeof filterQuestions>>
>;
export type FilterQuestionsMutationBody = QuestionFilterDto;
export type FilterQuestionsMutationError = unknown;

export const useFilterQuestions = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof filterQuestions>>,
      TError,
      { data: QuestionFilterDto },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof filterQuestions>>,
  TError,
  { data: QuestionFilterDto },
  TContext
> => {
  const mutationOptions = getFilterQuestionsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const duplicateQuestions = (
  duplicateQuestionsBody: string[],
  params: DuplicateQuestionsParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ExamQuestionDto[]>(
    {
      url: `/exam/exam-questions/duplicate`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: duplicateQuestionsBody,
      params,
      signal,
    },
    options,
  );
};

export const getDuplicateQuestionsMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof duplicateQuestions>>,
    TError,
    { data: string[]; params: DuplicateQuestionsParams },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof duplicateQuestions>>,
  TError,
  { data: string[]; params: DuplicateQuestionsParams },
  TContext
> => {
  const mutationKey = ["duplicateQuestions"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof duplicateQuestions>>,
    { data: string[]; params: DuplicateQuestionsParams }
  > = (props) => {
    const { data, params } = props ?? {};

    return duplicateQuestions(data, params, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DuplicateQuestionsMutationResult = NonNullable<
  Awaited<ReturnType<typeof duplicateQuestions>>
>;
export type DuplicateQuestionsMutationBody = string[];
export type DuplicateQuestionsMutationError = unknown;

export const useDuplicateQuestions = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof duplicateQuestions>>,
      TError,
      { data: string[]; params: DuplicateQuestionsParams },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof duplicateQuestions>>,
  TError,
  { data: string[]; params: DuplicateQuestionsParams },
  TContext
> => {
  const mutationOptions = getDuplicateQuestionsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const getQuestionWithTemplate = (
  questionId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ExamQuestionDto>(
    {
      url: `/exam/exam-questions/${questionId}/with-template`,
      method: "GET",
      signal,
    },
    options,
  );
};

export const getGetQuestionWithTemplateQueryKey = (questionId?: string) => {
  return [`/exam/exam-questions/${questionId}/with-template`] as const;
};

export const getGetQuestionWithTemplateQueryOptions = <
  TData = Awaited<ReturnType<typeof getQuestionWithTemplate>>,
  TError = unknown,
>(
  questionId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionWithTemplate>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetQuestionWithTemplateQueryKey(questionId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getQuestionWithTemplate>>
  > = ({ signal }) =>
    getQuestionWithTemplate(questionId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!questionId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getQuestionWithTemplate>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetQuestionWithTemplateQueryResult = NonNullable<
  Awaited<ReturnType<typeof getQuestionWithTemplate>>
>;
export type GetQuestionWithTemplateQueryError = unknown;

export function useGetQuestionWithTemplate<
  TData = Awaited<ReturnType<typeof getQuestionWithTemplate>>,
  TError = unknown,
>(
  questionId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionWithTemplate>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getQuestionWithTemplate>>,
          TError,
          Awaited<ReturnType<typeof getQuestionWithTemplate>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetQuestionWithTemplate<
  TData = Awaited<ReturnType<typeof getQuestionWithTemplate>>,
  TError = unknown,
>(
  questionId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionWithTemplate>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getQuestionWithTemplate>>,
          TError,
          Awaited<ReturnType<typeof getQuestionWithTemplate>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetQuestionWithTemplate<
  TData = Awaited<ReturnType<typeof getQuestionWithTemplate>>,
  TError = unknown,
>(
  questionId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionWithTemplate>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetQuestionWithTemplate<
  TData = Awaited<ReturnType<typeof getQuestionWithTemplate>>,
  TError = unknown,
>(
  questionId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionWithTemplate>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetQuestionWithTemplateQueryOptions(
    questionId,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getQuestionStatistics = (
  questionId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<QuestionStatisticsDto>(
    {
      url: `/exam/exam-questions/${questionId}/statistics`,
      method: "GET",
      signal,
    },
    options,
  );
};

export const getGetQuestionStatisticsQueryKey = (questionId?: string) => {
  return [`/exam/exam-questions/${questionId}/statistics`] as const;
};

export const getGetQuestionStatisticsQueryOptions = <
  TData = Awaited<ReturnType<typeof getQuestionStatistics>>,
  TError = unknown,
>(
  questionId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionStatistics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetQuestionStatisticsQueryKey(questionId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getQuestionStatistics>>
  > = ({ signal }) => getQuestionStatistics(questionId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!questionId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getQuestionStatistics>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetQuestionStatisticsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getQuestionStatistics>>
>;
export type GetQuestionStatisticsQueryError = unknown;

export function useGetQuestionStatistics<
  TData = Awaited<ReturnType<typeof getQuestionStatistics>>,
  TError = unknown,
>(
  questionId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionStatistics>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getQuestionStatistics>>,
          TError,
          Awaited<ReturnType<typeof getQuestionStatistics>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetQuestionStatistics<
  TData = Awaited<ReturnType<typeof getQuestionStatistics>>,
  TError = unknown,
>(
  questionId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionStatistics>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getQuestionStatistics>>,
          TError,
          Awaited<ReturnType<typeof getQuestionStatistics>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetQuestionStatistics<
  TData = Awaited<ReturnType<typeof getQuestionStatistics>>,
  TError = unknown,
>(
  questionId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionStatistics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetQuestionStatistics<
  TData = Awaited<ReturnType<typeof getQuestionStatistics>>,
  TError = unknown,
>(
  questionId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionStatistics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetQuestionStatisticsQueryOptions(
    questionId,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const isQuestionInUse = (
  questionId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<boolean>(
    { url: `/exam/exam-questions/${questionId}/in-use`, method: "GET", signal },
    options,
  );
};

export const getIsQuestionInUseQueryKey = (questionId?: string) => {
  return [`/exam/exam-questions/${questionId}/in-use`] as const;
};

export const getIsQuestionInUseQueryOptions = <
  TData = Awaited<ReturnType<typeof isQuestionInUse>>,
  TError = unknown,
>(
  questionId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof isQuestionInUse>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getIsQuestionInUseQueryKey(questionId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof isQuestionInUse>>> = ({
    signal,
  }) => isQuestionInUse(questionId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!questionId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof isQuestionInUse>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type IsQuestionInUseQueryResult = NonNullable<
  Awaited<ReturnType<typeof isQuestionInUse>>
>;
export type IsQuestionInUseQueryError = unknown;

export function useIsQuestionInUse<
  TData = Awaited<ReturnType<typeof isQuestionInUse>>,
  TError = unknown,
>(
  questionId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof isQuestionInUse>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof isQuestionInUse>>,
          TError,
          Awaited<ReturnType<typeof isQuestionInUse>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useIsQuestionInUse<
  TData = Awaited<ReturnType<typeof isQuestionInUse>>,
  TError = unknown,
>(
  questionId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof isQuestionInUse>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof isQuestionInUse>>,
          TError,
          Awaited<ReturnType<typeof isQuestionInUse>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useIsQuestionInUse<
  TData = Awaited<ReturnType<typeof isQuestionInUse>>,
  TError = unknown,
>(
  questionId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof isQuestionInUse>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useIsQuestionInUse<
  TData = Awaited<ReturnType<typeof isQuestionInUse>>,
  TError = unknown,
>(
  questionId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof isQuestionInUse>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getIsQuestionInUseQueryOptions(questionId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const hasTemplate = (
  questionId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<boolean>(
    {
      url: `/exam/exam-questions/${questionId}/has-template`,
      method: "GET",
      signal,
    },
    options,
  );
};

export const getHasTemplateQueryKey = (questionId?: string) => {
  return [`/exam/exam-questions/${questionId}/has-template`] as const;
};

export const getHasTemplateQueryOptions = <
  TData = Awaited<ReturnType<typeof hasTemplate>>,
  TError = unknown,
>(
  questionId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof hasTemplate>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getHasTemplateQueryKey(questionId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof hasTemplate>>> = ({
    signal,
  }) => hasTemplate(questionId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!questionId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof hasTemplate>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type HasTemplateQueryResult = NonNullable<
  Awaited<ReturnType<typeof hasTemplate>>
>;
export type HasTemplateQueryError = unknown;

export function useHasTemplate<
  TData = Awaited<ReturnType<typeof hasTemplate>>,
  TError = unknown,
>(
  questionId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof hasTemplate>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof hasTemplate>>,
          TError,
          Awaited<ReturnType<typeof hasTemplate>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHasTemplate<
  TData = Awaited<ReturnType<typeof hasTemplate>>,
  TError = unknown,
>(
  questionId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof hasTemplate>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof hasTemplate>>,
          TError,
          Awaited<ReturnType<typeof hasTemplate>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHasTemplate<
  TData = Awaited<ReturnType<typeof hasTemplate>>,
  TError = unknown,
>(
  questionId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof hasTemplate>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useHasTemplate<
  TData = Awaited<ReturnType<typeof hasTemplate>>,
  TError = unknown,
>(
  questionId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof hasTemplate>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getHasTemplateQueryOptions(questionId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getQuestionTypeDistribution = (
  examId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetQuestionTypeDistribution200>(
    {
      url: `/exam/exam-questions/${examId}/type-distribution`,
      method: "GET",
      signal,
    },
    options,
  );
};

export const getGetQuestionTypeDistributionQueryKey = (examId?: string) => {
  return [`/exam/exam-questions/${examId}/type-distribution`] as const;
};

export const getGetQuestionTypeDistributionQueryOptions = <
  TData = Awaited<ReturnType<typeof getQuestionTypeDistribution>>,
  TError = unknown,
>(
  examId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionTypeDistribution>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetQuestionTypeDistributionQueryKey(examId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getQuestionTypeDistribution>>
  > = ({ signal }) =>
    getQuestionTypeDistribution(examId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!examId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getQuestionTypeDistribution>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetQuestionTypeDistributionQueryResult = NonNullable<
  Awaited<ReturnType<typeof getQuestionTypeDistribution>>
>;
export type GetQuestionTypeDistributionQueryError = unknown;

export function useGetQuestionTypeDistribution<
  TData = Awaited<ReturnType<typeof getQuestionTypeDistribution>>,
  TError = unknown,
>(
  examId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionTypeDistribution>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getQuestionTypeDistribution>>,
          TError,
          Awaited<ReturnType<typeof getQuestionTypeDistribution>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetQuestionTypeDistribution<
  TData = Awaited<ReturnType<typeof getQuestionTypeDistribution>>,
  TError = unknown,
>(
  examId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionTypeDistribution>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getQuestionTypeDistribution>>,
          TError,
          Awaited<ReturnType<typeof getQuestionTypeDistribution>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetQuestionTypeDistribution<
  TData = Awaited<ReturnType<typeof getQuestionTypeDistribution>>,
  TError = unknown,
>(
  examId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionTypeDistribution>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetQuestionTypeDistribution<
  TData = Awaited<ReturnType<typeof getQuestionTypeDistribution>>,
  TError = unknown,
>(
  examId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionTypeDistribution>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetQuestionTypeDistributionQueryOptions(
    examId,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getTotalTimeLimitByExam = (
  examId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<number>(
    {
      url: `/exam/exam-questions/${examId}/total-time-limit`,
      method: "GET",
      signal,
    },
    options,
  );
};

export const getGetTotalTimeLimitByExamQueryKey = (examId?: string) => {
  return [`/exam/exam-questions/${examId}/total-time-limit`] as const;
};

export const getGetTotalTimeLimitByExamQueryOptions = <
  TData = Awaited<ReturnType<typeof getTotalTimeLimitByExam>>,
  TError = unknown,
>(
  examId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTotalTimeLimitByExam>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetTotalTimeLimitByExamQueryKey(examId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTotalTimeLimitByExam>>
  > = ({ signal }) => getTotalTimeLimitByExam(examId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!examId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getTotalTimeLimitByExam>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTotalTimeLimitByExamQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTotalTimeLimitByExam>>
>;
export type GetTotalTimeLimitByExamQueryError = unknown;

export function useGetTotalTimeLimitByExam<
  TData = Awaited<ReturnType<typeof getTotalTimeLimitByExam>>,
  TError = unknown,
>(
  examId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTotalTimeLimitByExam>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTotalTimeLimitByExam>>,
          TError,
          Awaited<ReturnType<typeof getTotalTimeLimitByExam>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTotalTimeLimitByExam<
  TData = Awaited<ReturnType<typeof getTotalTimeLimitByExam>>,
  TError = unknown,
>(
  examId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTotalTimeLimitByExam>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTotalTimeLimitByExam>>,
          TError,
          Awaited<ReturnType<typeof getTotalTimeLimitByExam>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTotalTimeLimitByExam<
  TData = Awaited<ReturnType<typeof getTotalTimeLimitByExam>>,
  TError = unknown,
>(
  examId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTotalTimeLimitByExam>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetTotalTimeLimitByExam<
  TData = Awaited<ReturnType<typeof getTotalTimeLimitByExam>>,
  TError = unknown,
>(
  examId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTotalTimeLimitByExam>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetTotalTimeLimitByExamQueryOptions(examId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getTotalPointsByExam = (
  examId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<number>(
    {
      url: `/exam/exam-questions/${examId}/total-points`,
      method: "GET",
      signal,
    },
    options,
  );
};

export const getGetTotalPointsByExamQueryKey = (examId?: string) => {
  return [`/exam/exam-questions/${examId}/total-points`] as const;
};

export const getGetTotalPointsByExamQueryOptions = <
  TData = Awaited<ReturnType<typeof getTotalPointsByExam>>,
  TError = unknown,
>(
  examId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTotalPointsByExam>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetTotalPointsByExamQueryKey(examId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTotalPointsByExam>>
  > = ({ signal }) => getTotalPointsByExam(examId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!examId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getTotalPointsByExam>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTotalPointsByExamQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTotalPointsByExam>>
>;
export type GetTotalPointsByExamQueryError = unknown;

export function useGetTotalPointsByExam<
  TData = Awaited<ReturnType<typeof getTotalPointsByExam>>,
  TError = unknown,
>(
  examId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTotalPointsByExam>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTotalPointsByExam>>,
          TError,
          Awaited<ReturnType<typeof getTotalPointsByExam>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTotalPointsByExam<
  TData = Awaited<ReturnType<typeof getTotalPointsByExam>>,
  TError = unknown,
>(
  examId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTotalPointsByExam>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTotalPointsByExam>>,
          TError,
          Awaited<ReturnType<typeof getTotalPointsByExam>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTotalPointsByExam<
  TData = Awaited<ReturnType<typeof getTotalPointsByExam>>,
  TError = unknown,
>(
  examId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTotalPointsByExam>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetTotalPointsByExam<
  TData = Awaited<ReturnType<typeof getTotalPointsByExam>>,
  TError = unknown,
>(
  examId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTotalPointsByExam>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetTotalPointsByExamQueryOptions(examId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getQuestionSkillDistribution = (
  examId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetQuestionSkillDistribution200>(
    {
      url: `/exam/exam-questions/${examId}/skill-distribution`,
      method: "GET",
      signal,
    },
    options,
  );
};

export const getGetQuestionSkillDistributionQueryKey = (examId?: string) => {
  return [`/exam/exam-questions/${examId}/skill-distribution`] as const;
};

export const getGetQuestionSkillDistributionQueryOptions = <
  TData = Awaited<ReturnType<typeof getQuestionSkillDistribution>>,
  TError = unknown,
>(
  examId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionSkillDistribution>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetQuestionSkillDistributionQueryKey(examId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getQuestionSkillDistribution>>
  > = ({ signal }) =>
    getQuestionSkillDistribution(examId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!examId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getQuestionSkillDistribution>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetQuestionSkillDistributionQueryResult = NonNullable<
  Awaited<ReturnType<typeof getQuestionSkillDistribution>>
>;
export type GetQuestionSkillDistributionQueryError = unknown;

export function useGetQuestionSkillDistribution<
  TData = Awaited<ReturnType<typeof getQuestionSkillDistribution>>,
  TError = unknown,
>(
  examId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionSkillDistribution>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getQuestionSkillDistribution>>,
          TError,
          Awaited<ReturnType<typeof getQuestionSkillDistribution>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetQuestionSkillDistribution<
  TData = Awaited<ReturnType<typeof getQuestionSkillDistribution>>,
  TError = unknown,
>(
  examId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionSkillDistribution>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getQuestionSkillDistribution>>,
          TError,
          Awaited<ReturnType<typeof getQuestionSkillDistribution>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetQuestionSkillDistribution<
  TData = Awaited<ReturnType<typeof getQuestionSkillDistribution>>,
  TError = unknown,
>(
  examId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionSkillDistribution>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetQuestionSkillDistribution<
  TData = Awaited<ReturnType<typeof getQuestionSkillDistribution>>,
  TError = unknown,
>(
  examId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionSkillDistribution>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetQuestionSkillDistributionQueryOptions(
    examId,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getQuestionsByType = (
  examId: string,
  type:
    | "MULTIPLE_CHOICE"
    | "TRUE_FALSE"
    | "FILL_IN_THE_BLANKS"
    | "SHORT_ANSWER"
    | "MATCHING"
    | "ESSAY"
    | "ORDERING"
    | "MULTIPLE_RESPONSE"
    | "HOT_SPOT"
    | "DRAG_AND_DROP"
    | "AUDIO_RESPONSE"
    | "VIDEO_RESPONSE"
    | "IMAGE_RESPONSE",
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ExamQuestionDto[]>(
    {
      url: `/exam/exam-questions/${examId}/by-type/${type}`,
      method: "GET",
      signal,
    },
    options,
  );
};

export const getGetQuestionsByTypeQueryKey = (
  examId?: string,
  type?:
    | "MULTIPLE_CHOICE"
    | "TRUE_FALSE"
    | "FILL_IN_THE_BLANKS"
    | "SHORT_ANSWER"
    | "MATCHING"
    | "ESSAY"
    | "ORDERING"
    | "MULTIPLE_RESPONSE"
    | "HOT_SPOT"
    | "DRAG_AND_DROP"
    | "AUDIO_RESPONSE"
    | "VIDEO_RESPONSE"
    | "IMAGE_RESPONSE",
) => {
  return [`/exam/exam-questions/${examId}/by-type/${type}`] as const;
};

export const getGetQuestionsByTypeQueryOptions = <
  TData = Awaited<ReturnType<typeof getQuestionsByType>>,
  TError = unknown,
>(
  examId: string,
  type:
    | "MULTIPLE_CHOICE"
    | "TRUE_FALSE"
    | "FILL_IN_THE_BLANKS"
    | "SHORT_ANSWER"
    | "MATCHING"
    | "ESSAY"
    | "ORDERING"
    | "MULTIPLE_RESPONSE"
    | "HOT_SPOT"
    | "DRAG_AND_DROP"
    | "AUDIO_RESPONSE"
    | "VIDEO_RESPONSE"
    | "IMAGE_RESPONSE",
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsByType>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetQuestionsByTypeQueryKey(examId, type);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getQuestionsByType>>
  > = ({ signal }) => getQuestionsByType(examId, type, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(examId && type),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getQuestionsByType>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetQuestionsByTypeQueryResult = NonNullable<
  Awaited<ReturnType<typeof getQuestionsByType>>
>;
export type GetQuestionsByTypeQueryError = unknown;

export function useGetQuestionsByType<
  TData = Awaited<ReturnType<typeof getQuestionsByType>>,
  TError = unknown,
>(
  examId: string,
  type:
    | "MULTIPLE_CHOICE"
    | "TRUE_FALSE"
    | "FILL_IN_THE_BLANKS"
    | "SHORT_ANSWER"
    | "MATCHING"
    | "ESSAY"
    | "ORDERING"
    | "MULTIPLE_RESPONSE"
    | "HOT_SPOT"
    | "DRAG_AND_DROP"
    | "AUDIO_RESPONSE"
    | "VIDEO_RESPONSE"
    | "IMAGE_RESPONSE",
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsByType>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getQuestionsByType>>,
          TError,
          Awaited<ReturnType<typeof getQuestionsByType>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetQuestionsByType<
  TData = Awaited<ReturnType<typeof getQuestionsByType>>,
  TError = unknown,
>(
  examId: string,
  type:
    | "MULTIPLE_CHOICE"
    | "TRUE_FALSE"
    | "FILL_IN_THE_BLANKS"
    | "SHORT_ANSWER"
    | "MATCHING"
    | "ESSAY"
    | "ORDERING"
    | "MULTIPLE_RESPONSE"
    | "HOT_SPOT"
    | "DRAG_AND_DROP"
    | "AUDIO_RESPONSE"
    | "VIDEO_RESPONSE"
    | "IMAGE_RESPONSE",
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsByType>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getQuestionsByType>>,
          TError,
          Awaited<ReturnType<typeof getQuestionsByType>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetQuestionsByType<
  TData = Awaited<ReturnType<typeof getQuestionsByType>>,
  TError = unknown,
>(
  examId: string,
  type:
    | "MULTIPLE_CHOICE"
    | "TRUE_FALSE"
    | "FILL_IN_THE_BLANKS"
    | "SHORT_ANSWER"
    | "MATCHING"
    | "ESSAY"
    | "ORDERING"
    | "MULTIPLE_RESPONSE"
    | "HOT_SPOT"
    | "DRAG_AND_DROP"
    | "AUDIO_RESPONSE"
    | "VIDEO_RESPONSE"
    | "IMAGE_RESPONSE",
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsByType>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetQuestionsByType<
  TData = Awaited<ReturnType<typeof getQuestionsByType>>,
  TError = unknown,
>(
  examId: string,
  type:
    | "MULTIPLE_CHOICE"
    | "TRUE_FALSE"
    | "FILL_IN_THE_BLANKS"
    | "SHORT_ANSWER"
    | "MATCHING"
    | "ESSAY"
    | "ORDERING"
    | "MULTIPLE_RESPONSE"
    | "HOT_SPOT"
    | "DRAG_AND_DROP"
    | "AUDIO_RESPONSE"
    | "VIDEO_RESPONSE"
    | "IMAGE_RESPONSE",
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsByType>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetQuestionsByTypeQueryOptions(examId, type, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getQuestionsBySkill = (
  examId: string,
  skill:
    | "SPEAKING"
    | "WRITING"
    | "LISTENING"
    | "READING"
    | "GRAMMAR"
    | "VOCABULARY"
    | "PRONUNCIATION"
    | "FLUENCY"
    | "COMPREHENSION",
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ExamQuestionDto[]>(
    {
      url: `/exam/exam-questions/${examId}/by-skill/${skill}`,
      method: "GET",
      signal,
    },
    options,
  );
};

export const getGetQuestionsBySkillQueryKey = (
  examId?: string,
  skill?:
    | "SPEAKING"
    | "WRITING"
    | "LISTENING"
    | "READING"
    | "GRAMMAR"
    | "VOCABULARY"
    | "PRONUNCIATION"
    | "FLUENCY"
    | "COMPREHENSION",
) => {
  return [`/exam/exam-questions/${examId}/by-skill/${skill}`] as const;
};

export const getGetQuestionsBySkillQueryOptions = <
  TData = Awaited<ReturnType<typeof getQuestionsBySkill>>,
  TError = unknown,
>(
  examId: string,
  skill:
    | "SPEAKING"
    | "WRITING"
    | "LISTENING"
    | "READING"
    | "GRAMMAR"
    | "VOCABULARY"
    | "PRONUNCIATION"
    | "FLUENCY"
    | "COMPREHENSION",
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsBySkill>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetQuestionsBySkillQueryKey(examId, skill);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getQuestionsBySkill>>
  > = ({ signal }) =>
    getQuestionsBySkill(examId, skill, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(examId && skill),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getQuestionsBySkill>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetQuestionsBySkillQueryResult = NonNullable<
  Awaited<ReturnType<typeof getQuestionsBySkill>>
>;
export type GetQuestionsBySkillQueryError = unknown;

export function useGetQuestionsBySkill<
  TData = Awaited<ReturnType<typeof getQuestionsBySkill>>,
  TError = unknown,
>(
  examId: string,
  skill:
    | "SPEAKING"
    | "WRITING"
    | "LISTENING"
    | "READING"
    | "GRAMMAR"
    | "VOCABULARY"
    | "PRONUNCIATION"
    | "FLUENCY"
    | "COMPREHENSION",
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsBySkill>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getQuestionsBySkill>>,
          TError,
          Awaited<ReturnType<typeof getQuestionsBySkill>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetQuestionsBySkill<
  TData = Awaited<ReturnType<typeof getQuestionsBySkill>>,
  TError = unknown,
>(
  examId: string,
  skill:
    | "SPEAKING"
    | "WRITING"
    | "LISTENING"
    | "READING"
    | "GRAMMAR"
    | "VOCABULARY"
    | "PRONUNCIATION"
    | "FLUENCY"
    | "COMPREHENSION",
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsBySkill>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getQuestionsBySkill>>,
          TError,
          Awaited<ReturnType<typeof getQuestionsBySkill>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetQuestionsBySkill<
  TData = Awaited<ReturnType<typeof getQuestionsBySkill>>,
  TError = unknown,
>(
  examId: string,
  skill:
    | "SPEAKING"
    | "WRITING"
    | "LISTENING"
    | "READING"
    | "GRAMMAR"
    | "VOCABULARY"
    | "PRONUNCIATION"
    | "FLUENCY"
    | "COMPREHENSION",
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsBySkill>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetQuestionsBySkill<
  TData = Awaited<ReturnType<typeof getQuestionsBySkill>>,
  TError = unknown,
>(
  examId: string,
  skill:
    | "SPEAKING"
    | "WRITING"
    | "LISTENING"
    | "READING"
    | "GRAMMAR"
    | "VOCABULARY"
    | "PRONUNCIATION"
    | "FLUENCY"
    | "COMPREHENSION",
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsBySkill>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetQuestionsBySkillQueryOptions(
    examId,
    skill,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getQuestionsByDifficulty = (
  examId: string,
  difficulty: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ExamQuestionDto[]>(
    {
      url: `/exam/exam-questions/${examId}/by-difficulty/${difficulty}`,
      method: "GET",
      signal,
    },
    options,
  );
};

export const getGetQuestionsByDifficultyQueryKey = (
  examId?: string,
  difficulty?: string,
) => {
  return [
    `/exam/exam-questions/${examId}/by-difficulty/${difficulty}`,
  ] as const;
};

export const getGetQuestionsByDifficultyQueryOptions = <
  TData = Awaited<ReturnType<typeof getQuestionsByDifficulty>>,
  TError = unknown,
>(
  examId: string,
  difficulty: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsByDifficulty>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetQuestionsByDifficultyQueryKey(examId, difficulty);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getQuestionsByDifficulty>>
  > = ({ signal }) =>
    getQuestionsByDifficulty(examId, difficulty, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(examId && difficulty),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getQuestionsByDifficulty>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetQuestionsByDifficultyQueryResult = NonNullable<
  Awaited<ReturnType<typeof getQuestionsByDifficulty>>
>;
export type GetQuestionsByDifficultyQueryError = unknown;

export function useGetQuestionsByDifficulty<
  TData = Awaited<ReturnType<typeof getQuestionsByDifficulty>>,
  TError = unknown,
>(
  examId: string,
  difficulty: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsByDifficulty>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getQuestionsByDifficulty>>,
          TError,
          Awaited<ReturnType<typeof getQuestionsByDifficulty>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetQuestionsByDifficulty<
  TData = Awaited<ReturnType<typeof getQuestionsByDifficulty>>,
  TError = unknown,
>(
  examId: string,
  difficulty: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsByDifficulty>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getQuestionsByDifficulty>>,
          TError,
          Awaited<ReturnType<typeof getQuestionsByDifficulty>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetQuestionsByDifficulty<
  TData = Awaited<ReturnType<typeof getQuestionsByDifficulty>>,
  TError = unknown,
>(
  examId: string,
  difficulty: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsByDifficulty>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetQuestionsByDifficulty<
  TData = Awaited<ReturnType<typeof getQuestionsByDifficulty>>,
  TError = unknown,
>(
  examId: string,
  difficulty: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsByDifficulty>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetQuestionsByDifficultyQueryOptions(
    examId,
    difficulty,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getQuestionAnalytics = (
  examId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<QuestionAnalyticsDto>(
    { url: `/exam/exam-questions/${examId}/analytics`, method: "GET", signal },
    options,
  );
};

export const getGetQuestionAnalyticsQueryKey = (examId?: string) => {
  return [`/exam/exam-questions/${examId}/analytics`] as const;
};

export const getGetQuestionAnalyticsQueryOptions = <
  TData = Awaited<ReturnType<typeof getQuestionAnalytics>>,
  TError = unknown,
>(
  examId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionAnalytics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetQuestionAnalyticsQueryKey(examId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getQuestionAnalytics>>
  > = ({ signal }) => getQuestionAnalytics(examId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!examId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getQuestionAnalytics>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetQuestionAnalyticsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getQuestionAnalytics>>
>;
export type GetQuestionAnalyticsQueryError = unknown;

export function useGetQuestionAnalytics<
  TData = Awaited<ReturnType<typeof getQuestionAnalytics>>,
  TError = unknown,
>(
  examId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionAnalytics>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getQuestionAnalytics>>,
          TError,
          Awaited<ReturnType<typeof getQuestionAnalytics>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetQuestionAnalytics<
  TData = Awaited<ReturnType<typeof getQuestionAnalytics>>,
  TError = unknown,
>(
  examId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionAnalytics>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getQuestionAnalytics>>,
          TError,
          Awaited<ReturnType<typeof getQuestionAnalytics>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetQuestionAnalytics<
  TData = Awaited<ReturnType<typeof getQuestionAnalytics>>,
  TError = unknown,
>(
  examId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionAnalytics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetQuestionAnalytics<
  TData = Awaited<ReturnType<typeof getQuestionAnalytics>>,
  TError = unknown,
>(
  examId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionAnalytics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetQuestionAnalyticsQueryOptions(examId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getQuestionsWithoutTemplate = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ExamQuestionDto[]>(
    { url: `/exam/exam-questions/without-template`, method: "GET", signal },
    options,
  );
};

export const getGetQuestionsWithoutTemplateQueryKey = () => {
  return [`/exam/exam-questions/without-template`] as const;
};

export const getGetQuestionsWithoutTemplateQueryOptions = <
  TData = Awaited<ReturnType<typeof getQuestionsWithoutTemplate>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getQuestionsWithoutTemplate>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetQuestionsWithoutTemplateQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getQuestionsWithoutTemplate>>
  > = ({ signal }) => getQuestionsWithoutTemplate(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getQuestionsWithoutTemplate>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetQuestionsWithoutTemplateQueryResult = NonNullable<
  Awaited<ReturnType<typeof getQuestionsWithoutTemplate>>
>;
export type GetQuestionsWithoutTemplateQueryError = unknown;

export function useGetQuestionsWithoutTemplate<
  TData = Awaited<ReturnType<typeof getQuestionsWithoutTemplate>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsWithoutTemplate>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getQuestionsWithoutTemplate>>,
          TError,
          Awaited<ReturnType<typeof getQuestionsWithoutTemplate>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetQuestionsWithoutTemplate<
  TData = Awaited<ReturnType<typeof getQuestionsWithoutTemplate>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsWithoutTemplate>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getQuestionsWithoutTemplate>>,
          TError,
          Awaited<ReturnType<typeof getQuestionsWithoutTemplate>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetQuestionsWithoutTemplate<
  TData = Awaited<ReturnType<typeof getQuestionsWithoutTemplate>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsWithoutTemplate>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetQuestionsWithoutTemplate<
  TData = Awaited<ReturnType<typeof getQuestionsWithoutTemplate>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsWithoutTemplate>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetQuestionsWithoutTemplateQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getTotalQuestionCount = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<number>(
    {
      url: `/exam/exam-questions/statistics/total-count`,
      method: "GET",
      signal,
    },
    options,
  );
};

export const getGetTotalQuestionCountQueryKey = () => {
  return [`/exam/exam-questions/statistics/total-count`] as const;
};

export const getGetTotalQuestionCountQueryOptions = <
  TData = Awaited<ReturnType<typeof getTotalQuestionCount>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getTotalQuestionCount>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTotalQuestionCountQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTotalQuestionCount>>
  > = ({ signal }) => getTotalQuestionCount(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getTotalQuestionCount>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTotalQuestionCountQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTotalQuestionCount>>
>;
export type GetTotalQuestionCountQueryError = unknown;

export function useGetTotalQuestionCount<
  TData = Awaited<ReturnType<typeof getTotalQuestionCount>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTotalQuestionCount>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTotalQuestionCount>>,
          TError,
          Awaited<ReturnType<typeof getTotalQuestionCount>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTotalQuestionCount<
  TData = Awaited<ReturnType<typeof getTotalQuestionCount>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTotalQuestionCount>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTotalQuestionCount>>,
          TError,
          Awaited<ReturnType<typeof getTotalQuestionCount>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTotalQuestionCount<
  TData = Awaited<ReturnType<typeof getTotalQuestionCount>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTotalQuestionCount>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetTotalQuestionCount<
  TData = Awaited<ReturnType<typeof getTotalQuestionCount>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTotalQuestionCount>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetTotalQuestionCountQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getQuestionCountByType = (
  type:
    | "MULTIPLE_CHOICE"
    | "TRUE_FALSE"
    | "FILL_IN_THE_BLANKS"
    | "SHORT_ANSWER"
    | "MATCHING"
    | "ESSAY"
    | "ORDERING"
    | "MULTIPLE_RESPONSE"
    | "HOT_SPOT"
    | "DRAG_AND_DROP"
    | "AUDIO_RESPONSE"
    | "VIDEO_RESPONSE"
    | "IMAGE_RESPONSE",
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<number>(
    {
      url: `/exam/exam-questions/statistics/count-by-type/${type}`,
      method: "GET",
      signal,
    },
    options,
  );
};

export const getGetQuestionCountByTypeQueryKey = (
  type?:
    | "MULTIPLE_CHOICE"
    | "TRUE_FALSE"
    | "FILL_IN_THE_BLANKS"
    | "SHORT_ANSWER"
    | "MATCHING"
    | "ESSAY"
    | "ORDERING"
    | "MULTIPLE_RESPONSE"
    | "HOT_SPOT"
    | "DRAG_AND_DROP"
    | "AUDIO_RESPONSE"
    | "VIDEO_RESPONSE"
    | "IMAGE_RESPONSE",
) => {
  return [`/exam/exam-questions/statistics/count-by-type/${type}`] as const;
};

export const getGetQuestionCountByTypeQueryOptions = <
  TData = Awaited<ReturnType<typeof getQuestionCountByType>>,
  TError = unknown,
>(
  type:
    | "MULTIPLE_CHOICE"
    | "TRUE_FALSE"
    | "FILL_IN_THE_BLANKS"
    | "SHORT_ANSWER"
    | "MATCHING"
    | "ESSAY"
    | "ORDERING"
    | "MULTIPLE_RESPONSE"
    | "HOT_SPOT"
    | "DRAG_AND_DROP"
    | "AUDIO_RESPONSE"
    | "VIDEO_RESPONSE"
    | "IMAGE_RESPONSE",
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionCountByType>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetQuestionCountByTypeQueryKey(type);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getQuestionCountByType>>
  > = ({ signal }) => getQuestionCountByType(type, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!type,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getQuestionCountByType>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetQuestionCountByTypeQueryResult = NonNullable<
  Awaited<ReturnType<typeof getQuestionCountByType>>
>;
export type GetQuestionCountByTypeQueryError = unknown;

export function useGetQuestionCountByType<
  TData = Awaited<ReturnType<typeof getQuestionCountByType>>,
  TError = unknown,
>(
  type:
    | "MULTIPLE_CHOICE"
    | "TRUE_FALSE"
    | "FILL_IN_THE_BLANKS"
    | "SHORT_ANSWER"
    | "MATCHING"
    | "ESSAY"
    | "ORDERING"
    | "MULTIPLE_RESPONSE"
    | "HOT_SPOT"
    | "DRAG_AND_DROP"
    | "AUDIO_RESPONSE"
    | "VIDEO_RESPONSE"
    | "IMAGE_RESPONSE",
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionCountByType>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getQuestionCountByType>>,
          TError,
          Awaited<ReturnType<typeof getQuestionCountByType>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetQuestionCountByType<
  TData = Awaited<ReturnType<typeof getQuestionCountByType>>,
  TError = unknown,
>(
  type:
    | "MULTIPLE_CHOICE"
    | "TRUE_FALSE"
    | "FILL_IN_THE_BLANKS"
    | "SHORT_ANSWER"
    | "MATCHING"
    | "ESSAY"
    | "ORDERING"
    | "MULTIPLE_RESPONSE"
    | "HOT_SPOT"
    | "DRAG_AND_DROP"
    | "AUDIO_RESPONSE"
    | "VIDEO_RESPONSE"
    | "IMAGE_RESPONSE",
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionCountByType>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getQuestionCountByType>>,
          TError,
          Awaited<ReturnType<typeof getQuestionCountByType>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetQuestionCountByType<
  TData = Awaited<ReturnType<typeof getQuestionCountByType>>,
  TError = unknown,
>(
  type:
    | "MULTIPLE_CHOICE"
    | "TRUE_FALSE"
    | "FILL_IN_THE_BLANKS"
    | "SHORT_ANSWER"
    | "MATCHING"
    | "ESSAY"
    | "ORDERING"
    | "MULTIPLE_RESPONSE"
    | "HOT_SPOT"
    | "DRAG_AND_DROP"
    | "AUDIO_RESPONSE"
    | "VIDEO_RESPONSE"
    | "IMAGE_RESPONSE",
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionCountByType>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetQuestionCountByType<
  TData = Awaited<ReturnType<typeof getQuestionCountByType>>,
  TError = unknown,
>(
  type:
    | "MULTIPLE_CHOICE"
    | "TRUE_FALSE"
    | "FILL_IN_THE_BLANKS"
    | "SHORT_ANSWER"
    | "MATCHING"
    | "ESSAY"
    | "ORDERING"
    | "MULTIPLE_RESPONSE"
    | "HOT_SPOT"
    | "DRAG_AND_DROP"
    | "AUDIO_RESPONSE"
    | "VIDEO_RESPONSE"
    | "IMAGE_RESPONSE",
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionCountByType>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetQuestionCountByTypeQueryOptions(type, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getQuestionCountByPart = (
  partId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<number>(
    {
      url: `/exam/exam-questions/statistics/count-by-part/${partId}`,
      method: "GET",
      signal,
    },
    options,
  );
};

export const getGetQuestionCountByPartQueryKey = (partId?: string) => {
  return [`/exam/exam-questions/statistics/count-by-part/${partId}`] as const;
};

export const getGetQuestionCountByPartQueryOptions = <
  TData = Awaited<ReturnType<typeof getQuestionCountByPart>>,
  TError = unknown,
>(
  partId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionCountByPart>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetQuestionCountByPartQueryKey(partId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getQuestionCountByPart>>
  > = ({ signal }) => getQuestionCountByPart(partId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!partId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getQuestionCountByPart>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetQuestionCountByPartQueryResult = NonNullable<
  Awaited<ReturnType<typeof getQuestionCountByPart>>
>;
export type GetQuestionCountByPartQueryError = unknown;

export function useGetQuestionCountByPart<
  TData = Awaited<ReturnType<typeof getQuestionCountByPart>>,
  TError = unknown,
>(
  partId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionCountByPart>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getQuestionCountByPart>>,
          TError,
          Awaited<ReturnType<typeof getQuestionCountByPart>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetQuestionCountByPart<
  TData = Awaited<ReturnType<typeof getQuestionCountByPart>>,
  TError = unknown,
>(
  partId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionCountByPart>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getQuestionCountByPart>>,
          TError,
          Awaited<ReturnType<typeof getQuestionCountByPart>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetQuestionCountByPart<
  TData = Awaited<ReturnType<typeof getQuestionCountByPart>>,
  TError = unknown,
>(
  partId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionCountByPart>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetQuestionCountByPart<
  TData = Awaited<ReturnType<typeof getQuestionCountByPart>>,
  TError = unknown,
>(
  partId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionCountByPart>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetQuestionCountByPartQueryOptions(partId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const searchQuestions = (
  params: SearchQuestionsParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ExamQuestionDto[]>(
    { url: `/exam/exam-questions/search`, method: "GET", params, signal },
    options,
  );
};

export const getSearchQuestionsQueryKey = (params?: SearchQuestionsParams) => {
  return [`/exam/exam-questions/search`, ...(params ? [params] : [])] as const;
};

export const getSearchQuestionsQueryOptions = <
  TData = Awaited<ReturnType<typeof searchQuestions>>,
  TError = unknown,
>(
  params: SearchQuestionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof searchQuestions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSearchQuestionsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof searchQuestions>>> = ({
    signal,
  }) => searchQuestions(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof searchQuestions>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SearchQuestionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof searchQuestions>>
>;
export type SearchQuestionsQueryError = unknown;

export function useSearchQuestions<
  TData = Awaited<ReturnType<typeof searchQuestions>>,
  TError = unknown,
>(
  params: SearchQuestionsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof searchQuestions>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchQuestions>>,
          TError,
          Awaited<ReturnType<typeof searchQuestions>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSearchQuestions<
  TData = Awaited<ReturnType<typeof searchQuestions>>,
  TError = unknown,
>(
  params: SearchQuestionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof searchQuestions>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchQuestions>>,
          TError,
          Awaited<ReturnType<typeof searchQuestions>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSearchQuestions<
  TData = Awaited<ReturnType<typeof searchQuestions>>,
  TError = unknown,
>(
  params: SearchQuestionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof searchQuestions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useSearchQuestions<
  TData = Awaited<ReturnType<typeof searchQuestions>>,
  TError = unknown,
>(
  params: SearchQuestionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof searchQuestions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSearchQuestionsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getMostRecentlyUpdated = (
  params?: GetMostRecentlyUpdatedParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ExamQuestionDto[]>(
    {
      url: `/exam/exam-questions/recently-updated`,
      method: "GET",
      params,
      signal,
    },
    options,
  );
};

export const getGetMostRecentlyUpdatedQueryKey = (
  params?: GetMostRecentlyUpdatedParams,
) => {
  return [
    `/exam/exam-questions/recently-updated`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetMostRecentlyUpdatedQueryOptions = <
  TData = Awaited<ReturnType<typeof getMostRecentlyUpdated>>,
  TError = unknown,
>(
  params?: GetMostRecentlyUpdatedParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMostRecentlyUpdated>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetMostRecentlyUpdatedQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getMostRecentlyUpdated>>
  > = ({ signal }) => getMostRecentlyUpdated(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMostRecentlyUpdated>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMostRecentlyUpdatedQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMostRecentlyUpdated>>
>;
export type GetMostRecentlyUpdatedQueryError = unknown;

export function useGetMostRecentlyUpdated<
  TData = Awaited<ReturnType<typeof getMostRecentlyUpdated>>,
  TError = unknown,
>(
  params: undefined | GetMostRecentlyUpdatedParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMostRecentlyUpdated>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMostRecentlyUpdated>>,
          TError,
          Awaited<ReturnType<typeof getMostRecentlyUpdated>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMostRecentlyUpdated<
  TData = Awaited<ReturnType<typeof getMostRecentlyUpdated>>,
  TError = unknown,
>(
  params?: GetMostRecentlyUpdatedParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMostRecentlyUpdated>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMostRecentlyUpdated>>,
          TError,
          Awaited<ReturnType<typeof getMostRecentlyUpdated>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMostRecentlyUpdated<
  TData = Awaited<ReturnType<typeof getMostRecentlyUpdated>>,
  TError = unknown,
>(
  params?: GetMostRecentlyUpdatedParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMostRecentlyUpdated>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetMostRecentlyUpdated<
  TData = Awaited<ReturnType<typeof getMostRecentlyUpdated>>,
  TError = unknown,
>(
  params?: GetMostRecentlyUpdatedParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMostRecentlyUpdated>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetMostRecentlyUpdatedQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getRecentQuestions = (
  params?: GetRecentQuestionsParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ExamQuestionDto[]>(
    { url: `/exam/exam-questions/recent`, method: "GET", params, signal },
    options,
  );
};

export const getGetRecentQuestionsQueryKey = (
  params?: GetRecentQuestionsParams,
) => {
  return [`/exam/exam-questions/recent`, ...(params ? [params] : [])] as const;
};

export const getGetRecentQuestionsQueryOptions = <
  TData = Awaited<ReturnType<typeof getRecentQuestions>>,
  TError = unknown,
>(
  params?: GetRecentQuestionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecentQuestions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetRecentQuestionsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getRecentQuestions>>
  > = ({ signal }) => getRecentQuestions(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getRecentQuestions>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetRecentQuestionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRecentQuestions>>
>;
export type GetRecentQuestionsQueryError = unknown;

export function useGetRecentQuestions<
  TData = Awaited<ReturnType<typeof getRecentQuestions>>,
  TError = unknown,
>(
  params: undefined | GetRecentQuestionsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecentQuestions>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecentQuestions>>,
          TError,
          Awaited<ReturnType<typeof getRecentQuestions>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRecentQuestions<
  TData = Awaited<ReturnType<typeof getRecentQuestions>>,
  TError = unknown,
>(
  params?: GetRecentQuestionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecentQuestions>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecentQuestions>>,
          TError,
          Awaited<ReturnType<typeof getRecentQuestions>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRecentQuestions<
  TData = Awaited<ReturnType<typeof getRecentQuestions>>,
  TError = unknown,
>(
  params?: GetRecentQuestionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecentQuestions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetRecentQuestions<
  TData = Awaited<ReturnType<typeof getRecentQuestions>>,
  TError = unknown,
>(
  params?: GetRecentQuestionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecentQuestions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetRecentQuestionsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getQuestionsPaginated = (
  params?: GetQuestionsPaginatedParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<PageExamQuestionDto>(
    { url: `/exam/exam-questions/paginated`, method: "GET", params, signal },
    options,
  );
};

export const getGetQuestionsPaginatedQueryKey = (
  params?: GetQuestionsPaginatedParams,
) => {
  return [
    `/exam/exam-questions/paginated`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetQuestionsPaginatedQueryOptions = <
  TData = Awaited<ReturnType<typeof getQuestionsPaginated>>,
  TError = unknown,
>(
  params?: GetQuestionsPaginatedParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsPaginated>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetQuestionsPaginatedQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getQuestionsPaginated>>
  > = ({ signal }) => getQuestionsPaginated(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getQuestionsPaginated>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetQuestionsPaginatedQueryResult = NonNullable<
  Awaited<ReturnType<typeof getQuestionsPaginated>>
>;
export type GetQuestionsPaginatedQueryError = unknown;

export function useGetQuestionsPaginated<
  TData = Awaited<ReturnType<typeof getQuestionsPaginated>>,
  TError = unknown,
>(
  params: undefined | GetQuestionsPaginatedParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsPaginated>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getQuestionsPaginated>>,
          TError,
          Awaited<ReturnType<typeof getQuestionsPaginated>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetQuestionsPaginated<
  TData = Awaited<ReturnType<typeof getQuestionsPaginated>>,
  TError = unknown,
>(
  params?: GetQuestionsPaginatedParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsPaginated>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getQuestionsPaginated>>,
          TError,
          Awaited<ReturnType<typeof getQuestionsPaginated>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetQuestionsPaginated<
  TData = Awaited<ReturnType<typeof getQuestionsPaginated>>,
  TError = unknown,
>(
  params?: GetQuestionsPaginatedParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsPaginated>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetQuestionsPaginated<
  TData = Awaited<ReturnType<typeof getQuestionsPaginated>>,
  TError = unknown,
>(
  params?: GetQuestionsPaginatedParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsPaginated>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetQuestionsPaginatedQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getMainQuestions = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ExamQuestionDto[]>(
    { url: `/exam/exam-questions/main-questions`, method: "GET", signal },
    options,
  );
};

export const getGetMainQuestionsQueryKey = () => {
  return [`/exam/exam-questions/main-questions`] as const;
};

export const getGetMainQuestionsQueryOptions = <
  TData = Awaited<ReturnType<typeof getMainQuestions>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getMainQuestions>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMainQuestionsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getMainQuestions>>
  > = ({ signal }) => getMainQuestions(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMainQuestions>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMainQuestionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMainQuestions>>
>;
export type GetMainQuestionsQueryError = unknown;

export function useGetMainQuestions<
  TData = Awaited<ReturnType<typeof getMainQuestions>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMainQuestions>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMainQuestions>>,
          TError,
          Awaited<ReturnType<typeof getMainQuestions>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMainQuestions<
  TData = Awaited<ReturnType<typeof getMainQuestions>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMainQuestions>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMainQuestions>>,
          TError,
          Awaited<ReturnType<typeof getMainQuestions>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMainQuestions<
  TData = Awaited<ReturnType<typeof getMainQuestions>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMainQuestions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetMainQuestions<
  TData = Awaited<ReturnType<typeof getMainQuestions>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMainQuestions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetMainQuestionsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getQuestionsByTemplate = (
  templateId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ExamQuestionDto[]>(
    {
      url: `/exam/exam-questions/by-template/${templateId}`,
      method: "GET",
      signal,
    },
    options,
  );
};

export const getGetQuestionsByTemplateQueryKey = (templateId?: string) => {
  return [`/exam/exam-questions/by-template/${templateId}`] as const;
};

export const getGetQuestionsByTemplateQueryOptions = <
  TData = Awaited<ReturnType<typeof getQuestionsByTemplate>>,
  TError = unknown,
>(
  templateId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsByTemplate>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetQuestionsByTemplateQueryKey(templateId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getQuestionsByTemplate>>
  > = ({ signal }) =>
    getQuestionsByTemplate(templateId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!templateId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getQuestionsByTemplate>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetQuestionsByTemplateQueryResult = NonNullable<
  Awaited<ReturnType<typeof getQuestionsByTemplate>>
>;
export type GetQuestionsByTemplateQueryError = unknown;

export function useGetQuestionsByTemplate<
  TData = Awaited<ReturnType<typeof getQuestionsByTemplate>>,
  TError = unknown,
>(
  templateId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsByTemplate>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getQuestionsByTemplate>>,
          TError,
          Awaited<ReturnType<typeof getQuestionsByTemplate>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetQuestionsByTemplate<
  TData = Awaited<ReturnType<typeof getQuestionsByTemplate>>,
  TError = unknown,
>(
  templateId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsByTemplate>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getQuestionsByTemplate>>,
          TError,
          Awaited<ReturnType<typeof getQuestionsByTemplate>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetQuestionsByTemplate<
  TData = Awaited<ReturnType<typeof getQuestionsByTemplate>>,
  TError = unknown,
>(
  templateId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsByTemplate>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetQuestionsByTemplate<
  TData = Awaited<ReturnType<typeof getQuestionsByTemplate>>,
  TError = unknown,
>(
  templateId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsByTemplate>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetQuestionsByTemplateQueryOptions(
    templateId,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getQuestionsByTag = (
  tag: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ExamQuestionDto[]>(
    { url: `/exam/exam-questions/by-tag/${tag}`, method: "GET", signal },
    options,
  );
};

export const getGetQuestionsByTagQueryKey = (tag?: string) => {
  return [`/exam/exam-questions/by-tag/${tag}`] as const;
};

export const getGetQuestionsByTagQueryOptions = <
  TData = Awaited<ReturnType<typeof getQuestionsByTag>>,
  TError = unknown,
>(
  tag: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsByTag>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetQuestionsByTagQueryKey(tag);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getQuestionsByTag>>
  > = ({ signal }) => getQuestionsByTag(tag, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!tag,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getQuestionsByTag>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetQuestionsByTagQueryResult = NonNullable<
  Awaited<ReturnType<typeof getQuestionsByTag>>
>;
export type GetQuestionsByTagQueryError = unknown;

export function useGetQuestionsByTag<
  TData = Awaited<ReturnType<typeof getQuestionsByTag>>,
  TError = unknown,
>(
  tag: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsByTag>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getQuestionsByTag>>,
          TError,
          Awaited<ReturnType<typeof getQuestionsByTag>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetQuestionsByTag<
  TData = Awaited<ReturnType<typeof getQuestionsByTag>>,
  TError = unknown,
>(
  tag: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsByTag>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getQuestionsByTag>>,
          TError,
          Awaited<ReturnType<typeof getQuestionsByTag>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetQuestionsByTag<
  TData = Awaited<ReturnType<typeof getQuestionsByTag>>,
  TError = unknown,
>(
  tag: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsByTag>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetQuestionsByTag<
  TData = Awaited<ReturnType<typeof getQuestionsByTag>>,
  TError = unknown,
>(
  tag: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsByTag>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetQuestionsByTagQueryOptions(tag, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getQuestionsByPartId = (
  partId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ExamQuestionDto[]>(
    { url: `/exam/exam-questions/by-part/${partId}`, method: "GET", signal },
    options,
  );
};

export const getGetQuestionsByPartIdQueryKey = (partId?: string) => {
  return [`/exam/exam-questions/by-part/${partId}`] as const;
};

export const getGetQuestionsByPartIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getQuestionsByPartId>>,
  TError = unknown,
>(
  partId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsByPartId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetQuestionsByPartIdQueryKey(partId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getQuestionsByPartId>>
  > = ({ signal }) => getQuestionsByPartId(partId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!partId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getQuestionsByPartId>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetQuestionsByPartIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getQuestionsByPartId>>
>;
export type GetQuestionsByPartIdQueryError = unknown;

export function useGetQuestionsByPartId<
  TData = Awaited<ReturnType<typeof getQuestionsByPartId>>,
  TError = unknown,
>(
  partId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsByPartId>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getQuestionsByPartId>>,
          TError,
          Awaited<ReturnType<typeof getQuestionsByPartId>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetQuestionsByPartId<
  TData = Awaited<ReturnType<typeof getQuestionsByPartId>>,
  TError = unknown,
>(
  partId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsByPartId>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getQuestionsByPartId>>,
          TError,
          Awaited<ReturnType<typeof getQuestionsByPartId>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetQuestionsByPartId<
  TData = Awaited<ReturnType<typeof getQuestionsByPartId>>,
  TError = unknown,
>(
  partId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsByPartId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetQuestionsByPartId<
  TData = Awaited<ReturnType<typeof getQuestionsByPartId>>,
  TError = unknown,
>(
  partId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsByPartId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetQuestionsByPartIdQueryOptions(partId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getQuestionsByExamId = (
  examId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ExamQuestionDto[]>(
    { url: `/exam/exam-questions/by-exam/${examId}`, method: "GET", signal },
    options,
  );
};

export const getGetQuestionsByExamIdQueryKey = (examId?: string) => {
  return [`/exam/exam-questions/by-exam/${examId}`] as const;
};

export const getGetQuestionsByExamIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getQuestionsByExamId>>,
  TError = unknown,
>(
  examId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsByExamId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetQuestionsByExamIdQueryKey(examId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getQuestionsByExamId>>
  > = ({ signal }) => getQuestionsByExamId(examId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!examId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getQuestionsByExamId>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetQuestionsByExamIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getQuestionsByExamId>>
>;
export type GetQuestionsByExamIdQueryError = unknown;

export function useGetQuestionsByExamId<
  TData = Awaited<ReturnType<typeof getQuestionsByExamId>>,
  TError = unknown,
>(
  examId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsByExamId>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getQuestionsByExamId>>,
          TError,
          Awaited<ReturnType<typeof getQuestionsByExamId>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetQuestionsByExamId<
  TData = Awaited<ReturnType<typeof getQuestionsByExamId>>,
  TError = unknown,
>(
  examId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsByExamId>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getQuestionsByExamId>>,
          TError,
          Awaited<ReturnType<typeof getQuestionsByExamId>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetQuestionsByExamId<
  TData = Awaited<ReturnType<typeof getQuestionsByExamId>>,
  TError = unknown,
>(
  examId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsByExamId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetQuestionsByExamId<
  TData = Awaited<ReturnType<typeof getQuestionsByExamId>>,
  TError = unknown,
>(
  examId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsByExamId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetQuestionsByExamIdQueryOptions(examId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getQuestionsByCurriculumContent = (
  curriculumContentId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ExamQuestionDto[]>(
    {
      url: `/exam/exam-questions/by-curriculum-content/${curriculumContentId}`,
      method: "GET",
      signal,
    },
    options,
  );
};

export const getGetQuestionsByCurriculumContentQueryKey = (
  curriculumContentId?: string,
) => {
  return [
    `/exam/exam-questions/by-curriculum-content/${curriculumContentId}`,
  ] as const;
};

export const getGetQuestionsByCurriculumContentQueryOptions = <
  TData = Awaited<ReturnType<typeof getQuestionsByCurriculumContent>>,
  TError = unknown,
>(
  curriculumContentId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsByCurriculumContent>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetQuestionsByCurriculumContentQueryKey(curriculumContentId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getQuestionsByCurriculumContent>>
  > = ({ signal }) =>
    getQuestionsByCurriculumContent(
      curriculumContentId,
      requestOptions,
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!curriculumContentId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getQuestionsByCurriculumContent>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetQuestionsByCurriculumContentQueryResult = NonNullable<
  Awaited<ReturnType<typeof getQuestionsByCurriculumContent>>
>;
export type GetQuestionsByCurriculumContentQueryError = unknown;

export function useGetQuestionsByCurriculumContent<
  TData = Awaited<ReturnType<typeof getQuestionsByCurriculumContent>>,
  TError = unknown,
>(
  curriculumContentId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsByCurriculumContent>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getQuestionsByCurriculumContent>>,
          TError,
          Awaited<ReturnType<typeof getQuestionsByCurriculumContent>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetQuestionsByCurriculumContent<
  TData = Awaited<ReturnType<typeof getQuestionsByCurriculumContent>>,
  TError = unknown,
>(
  curriculumContentId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsByCurriculumContent>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getQuestionsByCurriculumContent>>,
          TError,
          Awaited<ReturnType<typeof getQuestionsByCurriculumContent>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetQuestionsByCurriculumContent<
  TData = Awaited<ReturnType<typeof getQuestionsByCurriculumContent>>,
  TError = unknown,
>(
  curriculumContentId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsByCurriculumContent>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetQuestionsByCurriculumContent<
  TData = Awaited<ReturnType<typeof getQuestionsByCurriculumContent>>,
  TError = unknown,
>(
  curriculumContentId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getQuestionsByCurriculumContent>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetQuestionsByCurriculumContentQueryOptions(
    curriculumContentId,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getActiveQuestions = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ExamQuestionDto[]>(
    { url: `/exam/exam-questions/active-questions`, method: "GET", signal },
    options,
  );
};

export const getGetActiveQuestionsQueryKey = () => {
  return [`/exam/exam-questions/active-questions`] as const;
};

export const getGetActiveQuestionsQueryOptions = <
  TData = Awaited<ReturnType<typeof getActiveQuestions>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getActiveQuestions>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetActiveQuestionsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getActiveQuestions>>
  > = ({ signal }) => getActiveQuestions(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getActiveQuestions>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetActiveQuestionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getActiveQuestions>>
>;
export type GetActiveQuestionsQueryError = unknown;

export function useGetActiveQuestions<
  TData = Awaited<ReturnType<typeof getActiveQuestions>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getActiveQuestions>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActiveQuestions>>,
          TError,
          Awaited<ReturnType<typeof getActiveQuestions>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetActiveQuestions<
  TData = Awaited<ReturnType<typeof getActiveQuestions>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getActiveQuestions>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActiveQuestions>>,
          TError,
          Awaited<ReturnType<typeof getActiveQuestions>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetActiveQuestions<
  TData = Awaited<ReturnType<typeof getActiveQuestions>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getActiveQuestions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetActiveQuestions<
  TData = Awaited<ReturnType<typeof getActiveQuestions>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getActiveQuestions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetActiveQuestionsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const bulkDeleteQuestions = (
  bulkDeleteQuestionsBody: string[],
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<string>(
    {
      url: `/exam/exam-questions/bulk-delete`,
      method: "DELETE",
      headers: { "Content-Type": "application/json" },
      data: bulkDeleteQuestionsBody,
    },
    options,
  );
};

export const getBulkDeleteQuestionsMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof bulkDeleteQuestions>>,
    TError,
    { data: string[] },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof bulkDeleteQuestions>>,
  TError,
  { data: string[] },
  TContext
> => {
  const mutationKey = ["bulkDeleteQuestions"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof bulkDeleteQuestions>>,
    { data: string[] }
  > = (props) => {
    const { data } = props ?? {};

    return bulkDeleteQuestions(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type BulkDeleteQuestionsMutationResult = NonNullable<
  Awaited<ReturnType<typeof bulkDeleteQuestions>>
>;
export type BulkDeleteQuestionsMutationBody = string[];
export type BulkDeleteQuestionsMutationError = unknown;

export const useBulkDeleteQuestions = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof bulkDeleteQuestions>>,
      TError,
      { data: string[] },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof bulkDeleteQuestions>>,
  TError,
  { data: string[] },
  TContext
> => {
  const mutationOptions = getBulkDeleteQuestionsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
