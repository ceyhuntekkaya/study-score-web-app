/**
 * Generated by orval v7.17.0 üç∫
 * Do not edit manually.
 * OpenAPI definition
 * OpenAPI spec version: v0
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import type {
  AudioResponseTemplateDto,
  BaseQuestionTemplateDto,
  DragAndDropTemplateDto,
  DuplicateTemplateParams,
  EssayTemplateDto,
  FillInTheBlanksTemplateDto,
  GetMostUsedTemplatesParams,
  GetRecentTemplatesParams,
  GetTemplateMap200,
  GetTemplateTypeStatistics200,
  HotSpotTemplateDto,
  ImageResponseTemplateDto,
  MatchingTemplateDto,
  MultipleChoiceTemplateDto,
  MultipleResponseTemplateDto,
  OrderingTemplateDto,
  SearchTemplatesParams,
  ShortAnswerTemplateDto,
  TemplateFilterDto,
  TemplateUsageStatsDto,
  TrueFalseTemplateDto,
  VideoResponseTemplateDto,
} from "../openAPIDefinition.schemas";

import { customInstance } from "../../../lib/api-client";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

export const getTemplateById = (
  templateId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<BaseQuestionTemplateDto>(
    { url: `/exam/exam-templates/${templateId}`, method: "GET", signal },
    options,
  );
};

export const getGetTemplateByIdQueryKey = (templateId?: string) => {
  return [`/exam/exam-templates/${templateId}`] as const;
};

export const getGetTemplateByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getTemplateById>>,
  TError = unknown,
>(
  templateId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTemplateById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetTemplateByIdQueryKey(templateId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTemplateById>>> = ({
    signal,
  }) => getTemplateById(templateId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!templateId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getTemplateById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTemplateByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTemplateById>>
>;
export type GetTemplateByIdQueryError = unknown;

export function useGetTemplateById<
  TData = Awaited<ReturnType<typeof getTemplateById>>,
  TError = unknown,
>(
  templateId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTemplateById>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTemplateById>>,
          TError,
          Awaited<ReturnType<typeof getTemplateById>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTemplateById<
  TData = Awaited<ReturnType<typeof getTemplateById>>,
  TError = unknown,
>(
  templateId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTemplateById>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTemplateById>>,
          TError,
          Awaited<ReturnType<typeof getTemplateById>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTemplateById<
  TData = Awaited<ReturnType<typeof getTemplateById>>,
  TError = unknown,
>(
  templateId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTemplateById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetTemplateById<
  TData = Awaited<ReturnType<typeof getTemplateById>>,
  TError = unknown,
>(
  templateId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTemplateById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetTemplateByIdQueryOptions(templateId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const updateTemplate = (
  templateId: string,
  baseQuestionTemplateDto: BaseQuestionTemplateDto,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<BaseQuestionTemplateDto>(
    {
      url: `/exam/exam-templates/${templateId}`,
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      data: baseQuestionTemplateDto,
    },
    options,
  );
};

export const getUpdateTemplateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateTemplate>>,
    TError,
    { templateId: string; data: BaseQuestionTemplateDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateTemplate>>,
  TError,
  { templateId: string; data: BaseQuestionTemplateDto },
  TContext
> => {
  const mutationKey = ["updateTemplate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateTemplate>>,
    { templateId: string; data: BaseQuestionTemplateDto }
  > = (props) => {
    const { templateId, data } = props ?? {};

    return updateTemplate(templateId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateTemplateMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateTemplate>>
>;
export type UpdateTemplateMutationBody = BaseQuestionTemplateDto;
export type UpdateTemplateMutationError = unknown;

export const useUpdateTemplate = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateTemplate>>,
      TError,
      { templateId: string; data: BaseQuestionTemplateDto },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateTemplate>>,
  TError,
  { templateId: string; data: BaseQuestionTemplateDto },
  TContext
> => {
  const mutationOptions = getUpdateTemplateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const deleteTemplate = (
  templateId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<string>(
    { url: `/exam/exam-templates/${templateId}`, method: "DELETE" },
    options,
  );
};

export const getDeleteTemplateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteTemplate>>,
    TError,
    { templateId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteTemplate>>,
  TError,
  { templateId: string },
  TContext
> => {
  const mutationKey = ["deleteTemplate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteTemplate>>,
    { templateId: string }
  > = (props) => {
    const { templateId } = props ?? {};

    return deleteTemplate(templateId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteTemplateMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteTemplate>>
>;

export type DeleteTemplateMutationError = unknown;

export const useDeleteTemplate = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteTemplate>>,
      TError,
      { templateId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteTemplate>>,
  TError,
  { templateId: string },
  TContext
> => {
  const mutationOptions = getDeleteTemplateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const deactivateTemplate = (
  templateId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<BaseQuestionTemplateDto>(
    { url: `/exam/exam-templates/${templateId}/deactivate`, method: "PUT" },
    options,
  );
};

export const getDeactivateTemplateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deactivateTemplate>>,
    TError,
    { templateId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deactivateTemplate>>,
  TError,
  { templateId: string },
  TContext
> => {
  const mutationKey = ["deactivateTemplate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deactivateTemplate>>,
    { templateId: string }
  > = (props) => {
    const { templateId } = props ?? {};

    return deactivateTemplate(templateId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeactivateTemplateMutationResult = NonNullable<
  Awaited<ReturnType<typeof deactivateTemplate>>
>;

export type DeactivateTemplateMutationError = unknown;

export const useDeactivateTemplate = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deactivateTemplate>>,
      TError,
      { templateId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deactivateTemplate>>,
  TError,
  { templateId: string },
  TContext
> => {
  const mutationOptions = getDeactivateTemplateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const activateTemplate = (
  templateId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<BaseQuestionTemplateDto>(
    { url: `/exam/exam-templates/${templateId}/activate`, method: "PUT" },
    options,
  );
};

export const getActivateTemplateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof activateTemplate>>,
    TError,
    { templateId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof activateTemplate>>,
  TError,
  { templateId: string },
  TContext
> => {
  const mutationKey = ["activateTemplate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof activateTemplate>>,
    { templateId: string }
  > = (props) => {
    const { templateId } = props ?? {};

    return activateTemplate(templateId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ActivateTemplateMutationResult = NonNullable<
  Awaited<ReturnType<typeof activateTemplate>>
>;

export type ActivateTemplateMutationError = unknown;

export const useActivateTemplate = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof activateTemplate>>,
      TError,
      { templateId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof activateTemplate>>,
  TError,
  { templateId: string },
  TContext
> => {
  const mutationOptions = getActivateTemplateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const getAllTemplates = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<BaseQuestionTemplateDto[]>(
    { url: `/exam/exam-templates`, method: "GET", signal },
    options,
  );
};

export const getGetAllTemplatesQueryKey = () => {
  return [`/exam/exam-templates`] as const;
};

export const getGetAllTemplatesQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllTemplates>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAllTemplates>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllTemplatesQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllTemplates>>> = ({
    signal,
  }) => getAllTemplates(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAllTemplates>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAllTemplatesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllTemplates>>
>;
export type GetAllTemplatesQueryError = unknown;

export function useGetAllTemplates<
  TData = Awaited<ReturnType<typeof getAllTemplates>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllTemplates>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllTemplates>>,
          TError,
          Awaited<ReturnType<typeof getAllTemplates>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAllTemplates<
  TData = Awaited<ReturnType<typeof getAllTemplates>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllTemplates>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllTemplates>>,
          TError,
          Awaited<ReturnType<typeof getAllTemplates>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAllTemplates<
  TData = Awaited<ReturnType<typeof getAllTemplates>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllTemplates>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetAllTemplates<
  TData = Awaited<ReturnType<typeof getAllTemplates>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllTemplates>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAllTemplatesQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const createTemplate = (
  baseQuestionTemplateDto: BaseQuestionTemplateDto,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<BaseQuestionTemplateDto>(
    {
      url: `/exam/exam-templates`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: baseQuestionTemplateDto,
      signal,
    },
    options,
  );
};

export const getCreateTemplateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createTemplate>>,
    TError,
    { data: BaseQuestionTemplateDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createTemplate>>,
  TError,
  { data: BaseQuestionTemplateDto },
  TContext
> => {
  const mutationKey = ["createTemplate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createTemplate>>,
    { data: BaseQuestionTemplateDto }
  > = (props) => {
    const { data } = props ?? {};

    return createTemplate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateTemplateMutationResult = NonNullable<
  Awaited<ReturnType<typeof createTemplate>>
>;
export type CreateTemplateMutationBody = BaseQuestionTemplateDto;
export type CreateTemplateMutationError = unknown;

export const useCreateTemplate = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createTemplate>>,
      TError,
      { data: BaseQuestionTemplateDto },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createTemplate>>,
  TError,
  { data: BaseQuestionTemplateDto },
  TContext
> => {
  const mutationOptions = getCreateTemplateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const duplicateTemplate = (
  templateId: string,
  params: DuplicateTemplateParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<BaseQuestionTemplateDto>(
    {
      url: `/exam/exam-templates/${templateId}/duplicate`,
      method: "POST",
      params,
      signal,
    },
    options,
  );
};

export const getDuplicateTemplateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof duplicateTemplate>>,
    TError,
    { templateId: string; params: DuplicateTemplateParams },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof duplicateTemplate>>,
  TError,
  { templateId: string; params: DuplicateTemplateParams },
  TContext
> => {
  const mutationKey = ["duplicateTemplate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof duplicateTemplate>>,
    { templateId: string; params: DuplicateTemplateParams }
  > = (props) => {
    const { templateId, params } = props ?? {};

    return duplicateTemplate(templateId, params, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DuplicateTemplateMutationResult = NonNullable<
  Awaited<ReturnType<typeof duplicateTemplate>>
>;

export type DuplicateTemplateMutationError = unknown;

export const useDuplicateTemplate = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof duplicateTemplate>>,
      TError,
      { templateId: string; params: DuplicateTemplateParams },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof duplicateTemplate>>,
  TError,
  { templateId: string; params: DuplicateTemplateParams },
  TContext
> => {
  const mutationOptions = getDuplicateTemplateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const createVideoResponseTemplate = (
  videoResponseTemplateDto: VideoResponseTemplateDto,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<VideoResponseTemplateDto>(
    {
      url: `/exam/exam-templates/video-response`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: videoResponseTemplateDto,
      signal,
    },
    options,
  );
};

export const getCreateVideoResponseTemplateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createVideoResponseTemplate>>,
    TError,
    { data: VideoResponseTemplateDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createVideoResponseTemplate>>,
  TError,
  { data: VideoResponseTemplateDto },
  TContext
> => {
  const mutationKey = ["createVideoResponseTemplate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createVideoResponseTemplate>>,
    { data: VideoResponseTemplateDto }
  > = (props) => {
    const { data } = props ?? {};

    return createVideoResponseTemplate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateVideoResponseTemplateMutationResult = NonNullable<
  Awaited<ReturnType<typeof createVideoResponseTemplate>>
>;
export type CreateVideoResponseTemplateMutationBody = VideoResponseTemplateDto;
export type CreateVideoResponseTemplateMutationError = unknown;

export const useCreateVideoResponseTemplate = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createVideoResponseTemplate>>,
      TError,
      { data: VideoResponseTemplateDto },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createVideoResponseTemplate>>,
  TError,
  { data: VideoResponseTemplateDto },
  TContext
> => {
  const mutationOptions =
    getCreateVideoResponseTemplateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const createTrueFalseTemplate = (
  trueFalseTemplateDto: TrueFalseTemplateDto,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<TrueFalseTemplateDto>(
    {
      url: `/exam/exam-templates/true-false`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: trueFalseTemplateDto,
      signal,
    },
    options,
  );
};

export const getCreateTrueFalseTemplateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createTrueFalseTemplate>>,
    TError,
    { data: TrueFalseTemplateDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createTrueFalseTemplate>>,
  TError,
  { data: TrueFalseTemplateDto },
  TContext
> => {
  const mutationKey = ["createTrueFalseTemplate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createTrueFalseTemplate>>,
    { data: TrueFalseTemplateDto }
  > = (props) => {
    const { data } = props ?? {};

    return createTrueFalseTemplate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateTrueFalseTemplateMutationResult = NonNullable<
  Awaited<ReturnType<typeof createTrueFalseTemplate>>
>;
export type CreateTrueFalseTemplateMutationBody = TrueFalseTemplateDto;
export type CreateTrueFalseTemplateMutationError = unknown;

export const useCreateTrueFalseTemplate = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createTrueFalseTemplate>>,
      TError,
      { data: TrueFalseTemplateDto },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createTrueFalseTemplate>>,
  TError,
  { data: TrueFalseTemplateDto },
  TContext
> => {
  const mutationOptions = getCreateTrueFalseTemplateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const createShortAnswerTemplate = (
  shortAnswerTemplateDto: ShortAnswerTemplateDto,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ShortAnswerTemplateDto>(
    {
      url: `/exam/exam-templates/short-answer`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: shortAnswerTemplateDto,
      signal,
    },
    options,
  );
};

export const getCreateShortAnswerTemplateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createShortAnswerTemplate>>,
    TError,
    { data: ShortAnswerTemplateDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createShortAnswerTemplate>>,
  TError,
  { data: ShortAnswerTemplateDto },
  TContext
> => {
  const mutationKey = ["createShortAnswerTemplate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createShortAnswerTemplate>>,
    { data: ShortAnswerTemplateDto }
  > = (props) => {
    const { data } = props ?? {};

    return createShortAnswerTemplate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateShortAnswerTemplateMutationResult = NonNullable<
  Awaited<ReturnType<typeof createShortAnswerTemplate>>
>;
export type CreateShortAnswerTemplateMutationBody = ShortAnswerTemplateDto;
export type CreateShortAnswerTemplateMutationError = unknown;

export const useCreateShortAnswerTemplate = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createShortAnswerTemplate>>,
      TError,
      { data: ShortAnswerTemplateDto },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createShortAnswerTemplate>>,
  TError,
  { data: ShortAnswerTemplateDto },
  TContext
> => {
  const mutationOptions = getCreateShortAnswerTemplateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const createOrderingTemplate = (
  orderingTemplateDto: OrderingTemplateDto,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<OrderingTemplateDto>(
    {
      url: `/exam/exam-templates/ordering`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: orderingTemplateDto,
      signal,
    },
    options,
  );
};

export const getCreateOrderingTemplateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createOrderingTemplate>>,
    TError,
    { data: OrderingTemplateDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createOrderingTemplate>>,
  TError,
  { data: OrderingTemplateDto },
  TContext
> => {
  const mutationKey = ["createOrderingTemplate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createOrderingTemplate>>,
    { data: OrderingTemplateDto }
  > = (props) => {
    const { data } = props ?? {};

    return createOrderingTemplate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateOrderingTemplateMutationResult = NonNullable<
  Awaited<ReturnType<typeof createOrderingTemplate>>
>;
export type CreateOrderingTemplateMutationBody = OrderingTemplateDto;
export type CreateOrderingTemplateMutationError = unknown;

export const useCreateOrderingTemplate = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createOrderingTemplate>>,
      TError,
      { data: OrderingTemplateDto },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createOrderingTemplate>>,
  TError,
  { data: OrderingTemplateDto },
  TContext
> => {
  const mutationOptions = getCreateOrderingTemplateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const createMultipleResponseTemplate = (
  multipleResponseTemplateDto: MultipleResponseTemplateDto,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<MultipleResponseTemplateDto>(
    {
      url: `/exam/exam-templates/multiple-response`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: multipleResponseTemplateDto,
      signal,
    },
    options,
  );
};

export const getCreateMultipleResponseTemplateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createMultipleResponseTemplate>>,
    TError,
    { data: MultipleResponseTemplateDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createMultipleResponseTemplate>>,
  TError,
  { data: MultipleResponseTemplateDto },
  TContext
> => {
  const mutationKey = ["createMultipleResponseTemplate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createMultipleResponseTemplate>>,
    { data: MultipleResponseTemplateDto }
  > = (props) => {
    const { data } = props ?? {};

    return createMultipleResponseTemplate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateMultipleResponseTemplateMutationResult = NonNullable<
  Awaited<ReturnType<typeof createMultipleResponseTemplate>>
>;
export type CreateMultipleResponseTemplateMutationBody =
  MultipleResponseTemplateDto;
export type CreateMultipleResponseTemplateMutationError = unknown;

export const useCreateMultipleResponseTemplate = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createMultipleResponseTemplate>>,
      TError,
      { data: MultipleResponseTemplateDto },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createMultipleResponseTemplate>>,
  TError,
  { data: MultipleResponseTemplateDto },
  TContext
> => {
  const mutationOptions =
    getCreateMultipleResponseTemplateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const createMultipleChoiceTemplate = (
  multipleChoiceTemplateDto: MultipleChoiceTemplateDto,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<MultipleChoiceTemplateDto>(
    {
      url: `/exam/exam-templates/multiple-choice`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: multipleChoiceTemplateDto,
      signal,
    },
    options,
  );
};

export const getCreateMultipleChoiceTemplateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createMultipleChoiceTemplate>>,
    TError,
    { data: MultipleChoiceTemplateDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createMultipleChoiceTemplate>>,
  TError,
  { data: MultipleChoiceTemplateDto },
  TContext
> => {
  const mutationKey = ["createMultipleChoiceTemplate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createMultipleChoiceTemplate>>,
    { data: MultipleChoiceTemplateDto }
  > = (props) => {
    const { data } = props ?? {};

    return createMultipleChoiceTemplate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateMultipleChoiceTemplateMutationResult = NonNullable<
  Awaited<ReturnType<typeof createMultipleChoiceTemplate>>
>;
export type CreateMultipleChoiceTemplateMutationBody =
  MultipleChoiceTemplateDto;
export type CreateMultipleChoiceTemplateMutationError = unknown;

export const useCreateMultipleChoiceTemplate = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createMultipleChoiceTemplate>>,
      TError,
      { data: MultipleChoiceTemplateDto },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createMultipleChoiceTemplate>>,
  TError,
  { data: MultipleChoiceTemplateDto },
  TContext
> => {
  const mutationOptions =
    getCreateMultipleChoiceTemplateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const createMatchingTemplate = (
  matchingTemplateDto: MatchingTemplateDto,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<MatchingTemplateDto>(
    {
      url: `/exam/exam-templates/matching`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: matchingTemplateDto,
      signal,
    },
    options,
  );
};

export const getCreateMatchingTemplateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createMatchingTemplate>>,
    TError,
    { data: MatchingTemplateDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createMatchingTemplate>>,
  TError,
  { data: MatchingTemplateDto },
  TContext
> => {
  const mutationKey = ["createMatchingTemplate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createMatchingTemplate>>,
    { data: MatchingTemplateDto }
  > = (props) => {
    const { data } = props ?? {};

    return createMatchingTemplate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateMatchingTemplateMutationResult = NonNullable<
  Awaited<ReturnType<typeof createMatchingTemplate>>
>;
export type CreateMatchingTemplateMutationBody = MatchingTemplateDto;
export type CreateMatchingTemplateMutationError = unknown;

export const useCreateMatchingTemplate = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createMatchingTemplate>>,
      TError,
      { data: MatchingTemplateDto },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createMatchingTemplate>>,
  TError,
  { data: MatchingTemplateDto },
  TContext
> => {
  const mutationOptions = getCreateMatchingTemplateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const createImageResponseTemplate = (
  imageResponseTemplateDto: ImageResponseTemplateDto,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ImageResponseTemplateDto>(
    {
      url: `/exam/exam-templates/image-response`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: imageResponseTemplateDto,
      signal,
    },
    options,
  );
};

export const getCreateImageResponseTemplateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createImageResponseTemplate>>,
    TError,
    { data: ImageResponseTemplateDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createImageResponseTemplate>>,
  TError,
  { data: ImageResponseTemplateDto },
  TContext
> => {
  const mutationKey = ["createImageResponseTemplate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createImageResponseTemplate>>,
    { data: ImageResponseTemplateDto }
  > = (props) => {
    const { data } = props ?? {};

    return createImageResponseTemplate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateImageResponseTemplateMutationResult = NonNullable<
  Awaited<ReturnType<typeof createImageResponseTemplate>>
>;
export type CreateImageResponseTemplateMutationBody = ImageResponseTemplateDto;
export type CreateImageResponseTemplateMutationError = unknown;

export const useCreateImageResponseTemplate = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createImageResponseTemplate>>,
      TError,
      { data: ImageResponseTemplateDto },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createImageResponseTemplate>>,
  TError,
  { data: ImageResponseTemplateDto },
  TContext
> => {
  const mutationOptions =
    getCreateImageResponseTemplateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const createHotSpotTemplate = (
  hotSpotTemplateDto: HotSpotTemplateDto,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<HotSpotTemplateDto>(
    {
      url: `/exam/exam-templates/hot-spot`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: hotSpotTemplateDto,
      signal,
    },
    options,
  );
};

export const getCreateHotSpotTemplateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createHotSpotTemplate>>,
    TError,
    { data: HotSpotTemplateDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createHotSpotTemplate>>,
  TError,
  { data: HotSpotTemplateDto },
  TContext
> => {
  const mutationKey = ["createHotSpotTemplate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createHotSpotTemplate>>,
    { data: HotSpotTemplateDto }
  > = (props) => {
    const { data } = props ?? {};

    return createHotSpotTemplate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateHotSpotTemplateMutationResult = NonNullable<
  Awaited<ReturnType<typeof createHotSpotTemplate>>
>;
export type CreateHotSpotTemplateMutationBody = HotSpotTemplateDto;
export type CreateHotSpotTemplateMutationError = unknown;

export const useCreateHotSpotTemplate = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createHotSpotTemplate>>,
      TError,
      { data: HotSpotTemplateDto },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createHotSpotTemplate>>,
  TError,
  { data: HotSpotTemplateDto },
  TContext
> => {
  const mutationOptions = getCreateHotSpotTemplateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const filterTemplates = (
  templateFilterDto: TemplateFilterDto,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<BaseQuestionTemplateDto[]>(
    {
      url: `/exam/exam-templates/filter`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: templateFilterDto,
      signal,
    },
    options,
  );
};

export const getFilterTemplatesMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof filterTemplates>>,
    TError,
    { data: TemplateFilterDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof filterTemplates>>,
  TError,
  { data: TemplateFilterDto },
  TContext
> => {
  const mutationKey = ["filterTemplates"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof filterTemplates>>,
    { data: TemplateFilterDto }
  > = (props) => {
    const { data } = props ?? {};

    return filterTemplates(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type FilterTemplatesMutationResult = NonNullable<
  Awaited<ReturnType<typeof filterTemplates>>
>;
export type FilterTemplatesMutationBody = TemplateFilterDto;
export type FilterTemplatesMutationError = unknown;

export const useFilterTemplates = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof filterTemplates>>,
      TError,
      { data: TemplateFilterDto },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof filterTemplates>>,
  TError,
  { data: TemplateFilterDto },
  TContext
> => {
  const mutationOptions = getFilterTemplatesMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const createFillInTheBlanksTemplate = (
  fillInTheBlanksTemplateDto: FillInTheBlanksTemplateDto,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<FillInTheBlanksTemplateDto>(
    {
      url: `/exam/exam-templates/fill-in-blanks`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: fillInTheBlanksTemplateDto,
      signal,
    },
    options,
  );
};

export const getCreateFillInTheBlanksTemplateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createFillInTheBlanksTemplate>>,
    TError,
    { data: FillInTheBlanksTemplateDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createFillInTheBlanksTemplate>>,
  TError,
  { data: FillInTheBlanksTemplateDto },
  TContext
> => {
  const mutationKey = ["createFillInTheBlanksTemplate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createFillInTheBlanksTemplate>>,
    { data: FillInTheBlanksTemplateDto }
  > = (props) => {
    const { data } = props ?? {};

    return createFillInTheBlanksTemplate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateFillInTheBlanksTemplateMutationResult = NonNullable<
  Awaited<ReturnType<typeof createFillInTheBlanksTemplate>>
>;
export type CreateFillInTheBlanksTemplateMutationBody =
  FillInTheBlanksTemplateDto;
export type CreateFillInTheBlanksTemplateMutationError = unknown;

export const useCreateFillInTheBlanksTemplate = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createFillInTheBlanksTemplate>>,
      TError,
      { data: FillInTheBlanksTemplateDto },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createFillInTheBlanksTemplate>>,
  TError,
  { data: FillInTheBlanksTemplateDto },
  TContext
> => {
  const mutationOptions =
    getCreateFillInTheBlanksTemplateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const createEssayTemplate = (
  essayTemplateDto: EssayTemplateDto,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<EssayTemplateDto>(
    {
      url: `/exam/exam-templates/essay`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: essayTemplateDto,
      signal,
    },
    options,
  );
};

export const getCreateEssayTemplateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createEssayTemplate>>,
    TError,
    { data: EssayTemplateDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createEssayTemplate>>,
  TError,
  { data: EssayTemplateDto },
  TContext
> => {
  const mutationKey = ["createEssayTemplate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createEssayTemplate>>,
    { data: EssayTemplateDto }
  > = (props) => {
    const { data } = props ?? {};

    return createEssayTemplate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateEssayTemplateMutationResult = NonNullable<
  Awaited<ReturnType<typeof createEssayTemplate>>
>;
export type CreateEssayTemplateMutationBody = EssayTemplateDto;
export type CreateEssayTemplateMutationError = unknown;

export const useCreateEssayTemplate = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createEssayTemplate>>,
      TError,
      { data: EssayTemplateDto },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createEssayTemplate>>,
  TError,
  { data: EssayTemplateDto },
  TContext
> => {
  const mutationOptions = getCreateEssayTemplateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const createDragAndDropTemplate = (
  dragAndDropTemplateDto: DragAndDropTemplateDto,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<DragAndDropTemplateDto>(
    {
      url: `/exam/exam-templates/drag-drop`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: dragAndDropTemplateDto,
      signal,
    },
    options,
  );
};

export const getCreateDragAndDropTemplateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createDragAndDropTemplate>>,
    TError,
    { data: DragAndDropTemplateDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createDragAndDropTemplate>>,
  TError,
  { data: DragAndDropTemplateDto },
  TContext
> => {
  const mutationKey = ["createDragAndDropTemplate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createDragAndDropTemplate>>,
    { data: DragAndDropTemplateDto }
  > = (props) => {
    const { data } = props ?? {};

    return createDragAndDropTemplate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateDragAndDropTemplateMutationResult = NonNullable<
  Awaited<ReturnType<typeof createDragAndDropTemplate>>
>;
export type CreateDragAndDropTemplateMutationBody = DragAndDropTemplateDto;
export type CreateDragAndDropTemplateMutationError = unknown;

export const useCreateDragAndDropTemplate = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createDragAndDropTemplate>>,
      TError,
      { data: DragAndDropTemplateDto },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createDragAndDropTemplate>>,
  TError,
  { data: DragAndDropTemplateDto },
  TContext
> => {
  const mutationOptions = getCreateDragAndDropTemplateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const getTemplateMap = (
  getTemplateMapBody: string[],
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetTemplateMap200>(
    {
      url: `/exam/exam-templates/bulk-get`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: getTemplateMapBody,
      signal,
    },
    options,
  );
};

export const getGetTemplateMapMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof getTemplateMap>>,
    TError,
    { data: string[] },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof getTemplateMap>>,
  TError,
  { data: string[] },
  TContext
> => {
  const mutationKey = ["getTemplateMap"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof getTemplateMap>>,
    { data: string[] }
  > = (props) => {
    const { data } = props ?? {};

    return getTemplateMap(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type GetTemplateMapMutationResult = NonNullable<
  Awaited<ReturnType<typeof getTemplateMap>>
>;
export type GetTemplateMapMutationBody = string[];
export type GetTemplateMapMutationError = unknown;

export const useGetTemplateMap = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof getTemplateMap>>,
      TError,
      { data: string[] },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof getTemplateMap>>,
  TError,
  { data: string[] },
  TContext
> => {
  const mutationOptions = getGetTemplateMapMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const createAudioResponseTemplate = (
  audioResponseTemplateDto: AudioResponseTemplateDto,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AudioResponseTemplateDto>(
    {
      url: `/exam/exam-templates/audio-response`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: audioResponseTemplateDto,
      signal,
    },
    options,
  );
};

export const getCreateAudioResponseTemplateMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createAudioResponseTemplate>>,
    TError,
    { data: AudioResponseTemplateDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createAudioResponseTemplate>>,
  TError,
  { data: AudioResponseTemplateDto },
  TContext
> => {
  const mutationKey = ["createAudioResponseTemplate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createAudioResponseTemplate>>,
    { data: AudioResponseTemplateDto }
  > = (props) => {
    const { data } = props ?? {};

    return createAudioResponseTemplate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateAudioResponseTemplateMutationResult = NonNullable<
  Awaited<ReturnType<typeof createAudioResponseTemplate>>
>;
export type CreateAudioResponseTemplateMutationBody = AudioResponseTemplateDto;
export type CreateAudioResponseTemplateMutationError = unknown;

export const useCreateAudioResponseTemplate = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createAudioResponseTemplate>>,
      TError,
      { data: AudioResponseTemplateDto },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createAudioResponseTemplate>>,
  TError,
  { data: AudioResponseTemplateDto },
  TContext
> => {
  const mutationOptions =
    getCreateAudioResponseTemplateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const getTemplateValidationErrors = (
  templateId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<string[]>(
    {
      url: `/exam/exam-templates/${templateId}/validation-errors`,
      method: "GET",
      signal,
    },
    options,
  );
};

export const getGetTemplateValidationErrorsQueryKey = (templateId?: string) => {
  return [`/exam/exam-templates/${templateId}/validation-errors`] as const;
};

export const getGetTemplateValidationErrorsQueryOptions = <
  TData = Awaited<ReturnType<typeof getTemplateValidationErrors>>,
  TError = unknown,
>(
  templateId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTemplateValidationErrors>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetTemplateValidationErrorsQueryKey(templateId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTemplateValidationErrors>>
  > = ({ signal }) =>
    getTemplateValidationErrors(templateId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!templateId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getTemplateValidationErrors>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTemplateValidationErrorsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTemplateValidationErrors>>
>;
export type GetTemplateValidationErrorsQueryError = unknown;

export function useGetTemplateValidationErrors<
  TData = Awaited<ReturnType<typeof getTemplateValidationErrors>>,
  TError = unknown,
>(
  templateId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTemplateValidationErrors>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTemplateValidationErrors>>,
          TError,
          Awaited<ReturnType<typeof getTemplateValidationErrors>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTemplateValidationErrors<
  TData = Awaited<ReturnType<typeof getTemplateValidationErrors>>,
  TError = unknown,
>(
  templateId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTemplateValidationErrors>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTemplateValidationErrors>>,
          TError,
          Awaited<ReturnType<typeof getTemplateValidationErrors>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTemplateValidationErrors<
  TData = Awaited<ReturnType<typeof getTemplateValidationErrors>>,
  TError = unknown,
>(
  templateId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTemplateValidationErrors>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetTemplateValidationErrors<
  TData = Awaited<ReturnType<typeof getTemplateValidationErrors>>,
  TError = unknown,
>(
  templateId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTemplateValidationErrors>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetTemplateValidationErrorsQueryOptions(
    templateId,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const validateTemplate = (
  templateId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<boolean>(
    {
      url: `/exam/exam-templates/${templateId}/validate`,
      method: "GET",
      signal,
    },
    options,
  );
};

export const getValidateTemplateQueryKey = (templateId?: string) => {
  return [`/exam/exam-templates/${templateId}/validate`] as const;
};

export const getValidateTemplateQueryOptions = <
  TData = Awaited<ReturnType<typeof validateTemplate>>,
  TError = unknown,
>(
  templateId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof validateTemplate>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getValidateTemplateQueryKey(templateId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof validateTemplate>>
  > = ({ signal }) => validateTemplate(templateId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!templateId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof validateTemplate>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ValidateTemplateQueryResult = NonNullable<
  Awaited<ReturnType<typeof validateTemplate>>
>;
export type ValidateTemplateQueryError = unknown;

export function useValidateTemplate<
  TData = Awaited<ReturnType<typeof validateTemplate>>,
  TError = unknown,
>(
  templateId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof validateTemplate>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof validateTemplate>>,
          TError,
          Awaited<ReturnType<typeof validateTemplate>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useValidateTemplate<
  TData = Awaited<ReturnType<typeof validateTemplate>>,
  TError = unknown,
>(
  templateId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof validateTemplate>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof validateTemplate>>,
          TError,
          Awaited<ReturnType<typeof validateTemplate>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useValidateTemplate<
  TData = Awaited<ReturnType<typeof validateTemplate>>,
  TError = unknown,
>(
  templateId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof validateTemplate>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useValidateTemplate<
  TData = Awaited<ReturnType<typeof validateTemplate>>,
  TError = unknown,
>(
  templateId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof validateTemplate>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getValidateTemplateQueryOptions(templateId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getTemplateUsageStats = (
  templateId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<TemplateUsageStatsDto>(
    {
      url: `/exam/exam-templates/${templateId}/usage-stats`,
      method: "GET",
      signal,
    },
    options,
  );
};

export const getGetTemplateUsageStatsQueryKey = (templateId?: string) => {
  return [`/exam/exam-templates/${templateId}/usage-stats`] as const;
};

export const getGetTemplateUsageStatsQueryOptions = <
  TData = Awaited<ReturnType<typeof getTemplateUsageStats>>,
  TError = unknown,
>(
  templateId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTemplateUsageStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetTemplateUsageStatsQueryKey(templateId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTemplateUsageStats>>
  > = ({ signal }) => getTemplateUsageStats(templateId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!templateId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getTemplateUsageStats>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTemplateUsageStatsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTemplateUsageStats>>
>;
export type GetTemplateUsageStatsQueryError = unknown;

export function useGetTemplateUsageStats<
  TData = Awaited<ReturnType<typeof getTemplateUsageStats>>,
  TError = unknown,
>(
  templateId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTemplateUsageStats>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTemplateUsageStats>>,
          TError,
          Awaited<ReturnType<typeof getTemplateUsageStats>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTemplateUsageStats<
  TData = Awaited<ReturnType<typeof getTemplateUsageStats>>,
  TError = unknown,
>(
  templateId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTemplateUsageStats>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTemplateUsageStats>>,
          TError,
          Awaited<ReturnType<typeof getTemplateUsageStats>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTemplateUsageStats<
  TData = Awaited<ReturnType<typeof getTemplateUsageStats>>,
  TError = unknown,
>(
  templateId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTemplateUsageStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetTemplateUsageStats<
  TData = Awaited<ReturnType<typeof getTemplateUsageStats>>,
  TError = unknown,
>(
  templateId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTemplateUsageStats>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetTemplateUsageStatsQueryOptions(
    templateId,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getTemplateByIdAndType = (
  templateId: string,
  type:
    | "MULTIPLE_CHOICE"
    | "TRUE_FALSE"
    | "FILL_IN_THE_BLANKS"
    | "SHORT_ANSWER"
    | "MATCHING"
    | "ESSAY"
    | "ORDERING"
    | "MULTIPLE_RESPONSE"
    | "HOT_SPOT"
    | "DRAG_AND_DROP"
    | "AUDIO_RESPONSE"
    | "VIDEO_RESPONSE"
    | "IMAGE_RESPONSE",
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<BaseQuestionTemplateDto>(
    {
      url: `/exam/exam-templates/${templateId}/type/${type}`,
      method: "GET",
      signal,
    },
    options,
  );
};

export const getGetTemplateByIdAndTypeQueryKey = (
  templateId?: string,
  type?:
    | "MULTIPLE_CHOICE"
    | "TRUE_FALSE"
    | "FILL_IN_THE_BLANKS"
    | "SHORT_ANSWER"
    | "MATCHING"
    | "ESSAY"
    | "ORDERING"
    | "MULTIPLE_RESPONSE"
    | "HOT_SPOT"
    | "DRAG_AND_DROP"
    | "AUDIO_RESPONSE"
    | "VIDEO_RESPONSE"
    | "IMAGE_RESPONSE",
) => {
  return [`/exam/exam-templates/${templateId}/type/${type}`] as const;
};

export const getGetTemplateByIdAndTypeQueryOptions = <
  TData = Awaited<ReturnType<typeof getTemplateByIdAndType>>,
  TError = unknown,
>(
  templateId: string,
  type:
    | "MULTIPLE_CHOICE"
    | "TRUE_FALSE"
    | "FILL_IN_THE_BLANKS"
    | "SHORT_ANSWER"
    | "MATCHING"
    | "ESSAY"
    | "ORDERING"
    | "MULTIPLE_RESPONSE"
    | "HOT_SPOT"
    | "DRAG_AND_DROP"
    | "AUDIO_RESPONSE"
    | "VIDEO_RESPONSE"
    | "IMAGE_RESPONSE",
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTemplateByIdAndType>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetTemplateByIdAndTypeQueryKey(templateId, type);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTemplateByIdAndType>>
  > = ({ signal }) =>
    getTemplateByIdAndType(templateId, type, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(templateId && type),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getTemplateByIdAndType>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTemplateByIdAndTypeQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTemplateByIdAndType>>
>;
export type GetTemplateByIdAndTypeQueryError = unknown;

export function useGetTemplateByIdAndType<
  TData = Awaited<ReturnType<typeof getTemplateByIdAndType>>,
  TError = unknown,
>(
  templateId: string,
  type:
    | "MULTIPLE_CHOICE"
    | "TRUE_FALSE"
    | "FILL_IN_THE_BLANKS"
    | "SHORT_ANSWER"
    | "MATCHING"
    | "ESSAY"
    | "ORDERING"
    | "MULTIPLE_RESPONSE"
    | "HOT_SPOT"
    | "DRAG_AND_DROP"
    | "AUDIO_RESPONSE"
    | "VIDEO_RESPONSE"
    | "IMAGE_RESPONSE",
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTemplateByIdAndType>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTemplateByIdAndType>>,
          TError,
          Awaited<ReturnType<typeof getTemplateByIdAndType>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTemplateByIdAndType<
  TData = Awaited<ReturnType<typeof getTemplateByIdAndType>>,
  TError = unknown,
>(
  templateId: string,
  type:
    | "MULTIPLE_CHOICE"
    | "TRUE_FALSE"
    | "FILL_IN_THE_BLANKS"
    | "SHORT_ANSWER"
    | "MATCHING"
    | "ESSAY"
    | "ORDERING"
    | "MULTIPLE_RESPONSE"
    | "HOT_SPOT"
    | "DRAG_AND_DROP"
    | "AUDIO_RESPONSE"
    | "VIDEO_RESPONSE"
    | "IMAGE_RESPONSE",
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTemplateByIdAndType>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTemplateByIdAndType>>,
          TError,
          Awaited<ReturnType<typeof getTemplateByIdAndType>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTemplateByIdAndType<
  TData = Awaited<ReturnType<typeof getTemplateByIdAndType>>,
  TError = unknown,
>(
  templateId: string,
  type:
    | "MULTIPLE_CHOICE"
    | "TRUE_FALSE"
    | "FILL_IN_THE_BLANKS"
    | "SHORT_ANSWER"
    | "MATCHING"
    | "ESSAY"
    | "ORDERING"
    | "MULTIPLE_RESPONSE"
    | "HOT_SPOT"
    | "DRAG_AND_DROP"
    | "AUDIO_RESPONSE"
    | "VIDEO_RESPONSE"
    | "IMAGE_RESPONSE",
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTemplateByIdAndType>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetTemplateByIdAndType<
  TData = Awaited<ReturnType<typeof getTemplateByIdAndType>>,
  TError = unknown,
>(
  templateId: string,
  type:
    | "MULTIPLE_CHOICE"
    | "TRUE_FALSE"
    | "FILL_IN_THE_BLANKS"
    | "SHORT_ANSWER"
    | "MATCHING"
    | "ESSAY"
    | "ORDERING"
    | "MULTIPLE_RESPONSE"
    | "HOT_SPOT"
    | "DRAG_AND_DROP"
    | "AUDIO_RESPONSE"
    | "VIDEO_RESPONSE"
    | "IMAGE_RESPONSE",
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTemplateByIdAndType>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetTemplateByIdAndTypeQueryOptions(
    templateId,
    type,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const isTemplateInUse = (
  templateId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<boolean>(
    { url: `/exam/exam-templates/${templateId}/in-use`, method: "GET", signal },
    options,
  );
};

export const getIsTemplateInUseQueryKey = (templateId?: string) => {
  return [`/exam/exam-templates/${templateId}/in-use`] as const;
};

export const getIsTemplateInUseQueryOptions = <
  TData = Awaited<ReturnType<typeof isTemplateInUse>>,
  TError = unknown,
>(
  templateId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof isTemplateInUse>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getIsTemplateInUseQueryKey(templateId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof isTemplateInUse>>> = ({
    signal,
  }) => isTemplateInUse(templateId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!templateId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof isTemplateInUse>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type IsTemplateInUseQueryResult = NonNullable<
  Awaited<ReturnType<typeof isTemplateInUse>>
>;
export type IsTemplateInUseQueryError = unknown;

export function useIsTemplateInUse<
  TData = Awaited<ReturnType<typeof isTemplateInUse>>,
  TError = unknown,
>(
  templateId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof isTemplateInUse>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof isTemplateInUse>>,
          TError,
          Awaited<ReturnType<typeof isTemplateInUse>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useIsTemplateInUse<
  TData = Awaited<ReturnType<typeof isTemplateInUse>>,
  TError = unknown,
>(
  templateId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof isTemplateInUse>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof isTemplateInUse>>,
          TError,
          Awaited<ReturnType<typeof isTemplateInUse>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useIsTemplateInUse<
  TData = Awaited<ReturnType<typeof isTemplateInUse>>,
  TError = unknown,
>(
  templateId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof isTemplateInUse>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useIsTemplateInUse<
  TData = Awaited<ReturnType<typeof isTemplateInUse>>,
  TError = unknown,
>(
  templateId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof isTemplateInUse>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getIsTemplateInUseQueryOptions(templateId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getExamsUsingTemplate = (
  templateId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<string[]>(
    {
      url: `/exam/exam-templates/${templateId}/exams-using`,
      method: "GET",
      signal,
    },
    options,
  );
};

export const getGetExamsUsingTemplateQueryKey = (templateId?: string) => {
  return [`/exam/exam-templates/${templateId}/exams-using`] as const;
};

export const getGetExamsUsingTemplateQueryOptions = <
  TData = Awaited<ReturnType<typeof getExamsUsingTemplate>>,
  TError = unknown,
>(
  templateId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamsUsingTemplate>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetExamsUsingTemplateQueryKey(templateId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getExamsUsingTemplate>>
  > = ({ signal }) => getExamsUsingTemplate(templateId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!templateId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getExamsUsingTemplate>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetExamsUsingTemplateQueryResult = NonNullable<
  Awaited<ReturnType<typeof getExamsUsingTemplate>>
>;
export type GetExamsUsingTemplateQueryError = unknown;

export function useGetExamsUsingTemplate<
  TData = Awaited<ReturnType<typeof getExamsUsingTemplate>>,
  TError = unknown,
>(
  templateId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamsUsingTemplate>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExamsUsingTemplate>>,
          TError,
          Awaited<ReturnType<typeof getExamsUsingTemplate>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExamsUsingTemplate<
  TData = Awaited<ReturnType<typeof getExamsUsingTemplate>>,
  TError = unknown,
>(
  templateId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamsUsingTemplate>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExamsUsingTemplate>>,
          TError,
          Awaited<ReturnType<typeof getExamsUsingTemplate>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExamsUsingTemplate<
  TData = Awaited<ReturnType<typeof getExamsUsingTemplate>>,
  TError = unknown,
>(
  templateId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamsUsingTemplate>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetExamsUsingTemplate<
  TData = Awaited<ReturnType<typeof getExamsUsingTemplate>>,
  TError = unknown,
>(
  templateId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExamsUsingTemplate>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetExamsUsingTemplateQueryOptions(
    templateId,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getTemplateTypeStatistics = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetTemplateTypeStatistics200>(
    {
      url: `/exam/exam-templates/statistics/type-distribution`,
      method: "GET",
      signal,
    },
    options,
  );
};

export const getGetTemplateTypeStatisticsQueryKey = () => {
  return [`/exam/exam-templates/statistics/type-distribution`] as const;
};

export const getGetTemplateTypeStatisticsQueryOptions = <
  TData = Awaited<ReturnType<typeof getTemplateTypeStatistics>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getTemplateTypeStatistics>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetTemplateTypeStatisticsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTemplateTypeStatistics>>
  > = ({ signal }) => getTemplateTypeStatistics(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getTemplateTypeStatistics>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTemplateTypeStatisticsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTemplateTypeStatistics>>
>;
export type GetTemplateTypeStatisticsQueryError = unknown;

export function useGetTemplateTypeStatistics<
  TData = Awaited<ReturnType<typeof getTemplateTypeStatistics>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTemplateTypeStatistics>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTemplateTypeStatistics>>,
          TError,
          Awaited<ReturnType<typeof getTemplateTypeStatistics>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTemplateTypeStatistics<
  TData = Awaited<ReturnType<typeof getTemplateTypeStatistics>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTemplateTypeStatistics>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTemplateTypeStatistics>>,
          TError,
          Awaited<ReturnType<typeof getTemplateTypeStatistics>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTemplateTypeStatistics<
  TData = Awaited<ReturnType<typeof getTemplateTypeStatistics>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTemplateTypeStatistics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetTemplateTypeStatistics<
  TData = Awaited<ReturnType<typeof getTemplateTypeStatistics>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTemplateTypeStatistics>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetTemplateTypeStatisticsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const searchTemplates = (
  params: SearchTemplatesParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<BaseQuestionTemplateDto[]>(
    { url: `/exam/exam-templates/search`, method: "GET", params, signal },
    options,
  );
};

export const getSearchTemplatesQueryKey = (params?: SearchTemplatesParams) => {
  return [`/exam/exam-templates/search`, ...(params ? [params] : [])] as const;
};

export const getSearchTemplatesQueryOptions = <
  TData = Awaited<ReturnType<typeof searchTemplates>>,
  TError = unknown,
>(
  params: SearchTemplatesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof searchTemplates>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSearchTemplatesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof searchTemplates>>> = ({
    signal,
  }) => searchTemplates(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof searchTemplates>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SearchTemplatesQueryResult = NonNullable<
  Awaited<ReturnType<typeof searchTemplates>>
>;
export type SearchTemplatesQueryError = unknown;

export function useSearchTemplates<
  TData = Awaited<ReturnType<typeof searchTemplates>>,
  TError = unknown,
>(
  params: SearchTemplatesParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof searchTemplates>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchTemplates>>,
          TError,
          Awaited<ReturnType<typeof searchTemplates>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSearchTemplates<
  TData = Awaited<ReturnType<typeof searchTemplates>>,
  TError = unknown,
>(
  params: SearchTemplatesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof searchTemplates>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchTemplates>>,
          TError,
          Awaited<ReturnType<typeof searchTemplates>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSearchTemplates<
  TData = Awaited<ReturnType<typeof searchTemplates>>,
  TError = unknown,
>(
  params: SearchTemplatesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof searchTemplates>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useSearchTemplates<
  TData = Awaited<ReturnType<typeof searchTemplates>>,
  TError = unknown,
>(
  params: SearchTemplatesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof searchTemplates>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSearchTemplatesQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getRecentTemplates = (
  params?: GetRecentTemplatesParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<BaseQuestionTemplateDto[]>(
    { url: `/exam/exam-templates/recent`, method: "GET", params, signal },
    options,
  );
};

export const getGetRecentTemplatesQueryKey = (
  params?: GetRecentTemplatesParams,
) => {
  return [`/exam/exam-templates/recent`, ...(params ? [params] : [])] as const;
};

export const getGetRecentTemplatesQueryOptions = <
  TData = Awaited<ReturnType<typeof getRecentTemplates>>,
  TError = unknown,
>(
  params?: GetRecentTemplatesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecentTemplates>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetRecentTemplatesQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getRecentTemplates>>
  > = ({ signal }) => getRecentTemplates(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getRecentTemplates>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetRecentTemplatesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRecentTemplates>>
>;
export type GetRecentTemplatesQueryError = unknown;

export function useGetRecentTemplates<
  TData = Awaited<ReturnType<typeof getRecentTemplates>>,
  TError = unknown,
>(
  params: undefined | GetRecentTemplatesParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecentTemplates>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecentTemplates>>,
          TError,
          Awaited<ReturnType<typeof getRecentTemplates>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRecentTemplates<
  TData = Awaited<ReturnType<typeof getRecentTemplates>>,
  TError = unknown,
>(
  params?: GetRecentTemplatesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecentTemplates>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecentTemplates>>,
          TError,
          Awaited<ReturnType<typeof getRecentTemplates>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRecentTemplates<
  TData = Awaited<ReturnType<typeof getRecentTemplates>>,
  TError = unknown,
>(
  params?: GetRecentTemplatesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecentTemplates>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetRecentTemplates<
  TData = Awaited<ReturnType<typeof getRecentTemplates>>,
  TError = unknown,
>(
  params?: GetRecentTemplatesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecentTemplates>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetRecentTemplatesQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getMostUsedTemplates = (
  params?: GetMostUsedTemplatesParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<BaseQuestionTemplateDto[]>(
    { url: `/exam/exam-templates/most-used`, method: "GET", params, signal },
    options,
  );
};

export const getGetMostUsedTemplatesQueryKey = (
  params?: GetMostUsedTemplatesParams,
) => {
  return [
    `/exam/exam-templates/most-used`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetMostUsedTemplatesQueryOptions = <
  TData = Awaited<ReturnType<typeof getMostUsedTemplates>>,
  TError = unknown,
>(
  params?: GetMostUsedTemplatesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMostUsedTemplates>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetMostUsedTemplatesQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getMostUsedTemplates>>
  > = ({ signal }) => getMostUsedTemplates(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMostUsedTemplates>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMostUsedTemplatesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMostUsedTemplates>>
>;
export type GetMostUsedTemplatesQueryError = unknown;

export function useGetMostUsedTemplates<
  TData = Awaited<ReturnType<typeof getMostUsedTemplates>>,
  TError = unknown,
>(
  params: undefined | GetMostUsedTemplatesParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMostUsedTemplates>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMostUsedTemplates>>,
          TError,
          Awaited<ReturnType<typeof getMostUsedTemplates>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMostUsedTemplates<
  TData = Awaited<ReturnType<typeof getMostUsedTemplates>>,
  TError = unknown,
>(
  params?: GetMostUsedTemplatesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMostUsedTemplates>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMostUsedTemplates>>,
          TError,
          Awaited<ReturnType<typeof getMostUsedTemplates>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMostUsedTemplates<
  TData = Awaited<ReturnType<typeof getMostUsedTemplates>>,
  TError = unknown,
>(
  params?: GetMostUsedTemplatesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMostUsedTemplates>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetMostUsedTemplates<
  TData = Awaited<ReturnType<typeof getMostUsedTemplates>>,
  TError = unknown,
>(
  params?: GetMostUsedTemplatesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMostUsedTemplates>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetMostUsedTemplatesQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getTemplatesByType = (
  type:
    | "MULTIPLE_CHOICE"
    | "TRUE_FALSE"
    | "FILL_IN_THE_BLANKS"
    | "SHORT_ANSWER"
    | "MATCHING"
    | "ESSAY"
    | "ORDERING"
    | "MULTIPLE_RESPONSE"
    | "HOT_SPOT"
    | "DRAG_AND_DROP"
    | "AUDIO_RESPONSE"
    | "VIDEO_RESPONSE"
    | "IMAGE_RESPONSE",
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<BaseQuestionTemplateDto[]>(
    { url: `/exam/exam-templates/by-type/${type}`, method: "GET", signal },
    options,
  );
};

export const getGetTemplatesByTypeQueryKey = (
  type?:
    | "MULTIPLE_CHOICE"
    | "TRUE_FALSE"
    | "FILL_IN_THE_BLANKS"
    | "SHORT_ANSWER"
    | "MATCHING"
    | "ESSAY"
    | "ORDERING"
    | "MULTIPLE_RESPONSE"
    | "HOT_SPOT"
    | "DRAG_AND_DROP"
    | "AUDIO_RESPONSE"
    | "VIDEO_RESPONSE"
    | "IMAGE_RESPONSE",
) => {
  return [`/exam/exam-templates/by-type/${type}`] as const;
};

export const getGetTemplatesByTypeQueryOptions = <
  TData = Awaited<ReturnType<typeof getTemplatesByType>>,
  TError = unknown,
>(
  type:
    | "MULTIPLE_CHOICE"
    | "TRUE_FALSE"
    | "FILL_IN_THE_BLANKS"
    | "SHORT_ANSWER"
    | "MATCHING"
    | "ESSAY"
    | "ORDERING"
    | "MULTIPLE_RESPONSE"
    | "HOT_SPOT"
    | "DRAG_AND_DROP"
    | "AUDIO_RESPONSE"
    | "VIDEO_RESPONSE"
    | "IMAGE_RESPONSE",
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTemplatesByType>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetTemplatesByTypeQueryKey(type);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTemplatesByType>>
  > = ({ signal }) => getTemplatesByType(type, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!type,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getTemplatesByType>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTemplatesByTypeQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTemplatesByType>>
>;
export type GetTemplatesByTypeQueryError = unknown;

export function useGetTemplatesByType<
  TData = Awaited<ReturnType<typeof getTemplatesByType>>,
  TError = unknown,
>(
  type:
    | "MULTIPLE_CHOICE"
    | "TRUE_FALSE"
    | "FILL_IN_THE_BLANKS"
    | "SHORT_ANSWER"
    | "MATCHING"
    | "ESSAY"
    | "ORDERING"
    | "MULTIPLE_RESPONSE"
    | "HOT_SPOT"
    | "DRAG_AND_DROP"
    | "AUDIO_RESPONSE"
    | "VIDEO_RESPONSE"
    | "IMAGE_RESPONSE",
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTemplatesByType>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTemplatesByType>>,
          TError,
          Awaited<ReturnType<typeof getTemplatesByType>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTemplatesByType<
  TData = Awaited<ReturnType<typeof getTemplatesByType>>,
  TError = unknown,
>(
  type:
    | "MULTIPLE_CHOICE"
    | "TRUE_FALSE"
    | "FILL_IN_THE_BLANKS"
    | "SHORT_ANSWER"
    | "MATCHING"
    | "ESSAY"
    | "ORDERING"
    | "MULTIPLE_RESPONSE"
    | "HOT_SPOT"
    | "DRAG_AND_DROP"
    | "AUDIO_RESPONSE"
    | "VIDEO_RESPONSE"
    | "IMAGE_RESPONSE",
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTemplatesByType>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTemplatesByType>>,
          TError,
          Awaited<ReturnType<typeof getTemplatesByType>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTemplatesByType<
  TData = Awaited<ReturnType<typeof getTemplatesByType>>,
  TError = unknown,
>(
  type:
    | "MULTIPLE_CHOICE"
    | "TRUE_FALSE"
    | "FILL_IN_THE_BLANKS"
    | "SHORT_ANSWER"
    | "MATCHING"
    | "ESSAY"
    | "ORDERING"
    | "MULTIPLE_RESPONSE"
    | "HOT_SPOT"
    | "DRAG_AND_DROP"
    | "AUDIO_RESPONSE"
    | "VIDEO_RESPONSE"
    | "IMAGE_RESPONSE",
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTemplatesByType>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetTemplatesByType<
  TData = Awaited<ReturnType<typeof getTemplatesByType>>,
  TError = unknown,
>(
  type:
    | "MULTIPLE_CHOICE"
    | "TRUE_FALSE"
    | "FILL_IN_THE_BLANKS"
    | "SHORT_ANSWER"
    | "MATCHING"
    | "ESSAY"
    | "ORDERING"
    | "MULTIPLE_RESPONSE"
    | "HOT_SPOT"
    | "DRAG_AND_DROP"
    | "AUDIO_RESPONSE"
    | "VIDEO_RESPONSE"
    | "IMAGE_RESPONSE",
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTemplatesByType>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetTemplatesByTypeQueryOptions(type, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getTemplatesBySubject = (
  subject: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<BaseQuestionTemplateDto[]>(
    {
      url: `/exam/exam-templates/by-subject/${subject}`,
      method: "GET",
      signal,
    },
    options,
  );
};

export const getGetTemplatesBySubjectQueryKey = (subject?: string) => {
  return [`/exam/exam-templates/by-subject/${subject}`] as const;
};

export const getGetTemplatesBySubjectQueryOptions = <
  TData = Awaited<ReturnType<typeof getTemplatesBySubject>>,
  TError = unknown,
>(
  subject: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTemplatesBySubject>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetTemplatesBySubjectQueryKey(subject);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTemplatesBySubject>>
  > = ({ signal }) => getTemplatesBySubject(subject, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!subject,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getTemplatesBySubject>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTemplatesBySubjectQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTemplatesBySubject>>
>;
export type GetTemplatesBySubjectQueryError = unknown;

export function useGetTemplatesBySubject<
  TData = Awaited<ReturnType<typeof getTemplatesBySubject>>,
  TError = unknown,
>(
  subject: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTemplatesBySubject>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTemplatesBySubject>>,
          TError,
          Awaited<ReturnType<typeof getTemplatesBySubject>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTemplatesBySubject<
  TData = Awaited<ReturnType<typeof getTemplatesBySubject>>,
  TError = unknown,
>(
  subject: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTemplatesBySubject>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTemplatesBySubject>>,
          TError,
          Awaited<ReturnType<typeof getTemplatesBySubject>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTemplatesBySubject<
  TData = Awaited<ReturnType<typeof getTemplatesBySubject>>,
  TError = unknown,
>(
  subject: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTemplatesBySubject>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetTemplatesBySubject<
  TData = Awaited<ReturnType<typeof getTemplatesBySubject>>,
  TError = unknown,
>(
  subject: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTemplatesBySubject>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetTemplatesBySubjectQueryOptions(subject, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getTemplatesByDifficulty = (
  difficulty: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<BaseQuestionTemplateDto[]>(
    {
      url: `/exam/exam-templates/by-difficulty/${difficulty}`,
      method: "GET",
      signal,
    },
    options,
  );
};

export const getGetTemplatesByDifficultyQueryKey = (difficulty?: string) => {
  return [`/exam/exam-templates/by-difficulty/${difficulty}`] as const;
};

export const getGetTemplatesByDifficultyQueryOptions = <
  TData = Awaited<ReturnType<typeof getTemplatesByDifficulty>>,
  TError = unknown,
>(
  difficulty: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTemplatesByDifficulty>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetTemplatesByDifficultyQueryKey(difficulty);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTemplatesByDifficulty>>
  > = ({ signal }) =>
    getTemplatesByDifficulty(difficulty, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!difficulty,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getTemplatesByDifficulty>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTemplatesByDifficultyQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTemplatesByDifficulty>>
>;
export type GetTemplatesByDifficultyQueryError = unknown;

export function useGetTemplatesByDifficulty<
  TData = Awaited<ReturnType<typeof getTemplatesByDifficulty>>,
  TError = unknown,
>(
  difficulty: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTemplatesByDifficulty>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTemplatesByDifficulty>>,
          TError,
          Awaited<ReturnType<typeof getTemplatesByDifficulty>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTemplatesByDifficulty<
  TData = Awaited<ReturnType<typeof getTemplatesByDifficulty>>,
  TError = unknown,
>(
  difficulty: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTemplatesByDifficulty>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTemplatesByDifficulty>>,
          TError,
          Awaited<ReturnType<typeof getTemplatesByDifficulty>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTemplatesByDifficulty<
  TData = Awaited<ReturnType<typeof getTemplatesByDifficulty>>,
  TError = unknown,
>(
  difficulty: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTemplatesByDifficulty>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetTemplatesByDifficulty<
  TData = Awaited<ReturnType<typeof getTemplatesByDifficulty>>,
  TError = unknown,
>(
  difficulty: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTemplatesByDifficulty>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetTemplatesByDifficultyQueryOptions(
    difficulty,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getTemplatesByCreator = (
  userId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<BaseQuestionTemplateDto[]>(
    { url: `/exam/exam-templates/by-creator/${userId}`, method: "GET", signal },
    options,
  );
};

export const getGetTemplatesByCreatorQueryKey = (userId?: string) => {
  return [`/exam/exam-templates/by-creator/${userId}`] as const;
};

export const getGetTemplatesByCreatorQueryOptions = <
  TData = Awaited<ReturnType<typeof getTemplatesByCreator>>,
  TError = unknown,
>(
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTemplatesByCreator>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetTemplatesByCreatorQueryKey(userId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTemplatesByCreator>>
  > = ({ signal }) => getTemplatesByCreator(userId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!userId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getTemplatesByCreator>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTemplatesByCreatorQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTemplatesByCreator>>
>;
export type GetTemplatesByCreatorQueryError = unknown;

export function useGetTemplatesByCreator<
  TData = Awaited<ReturnType<typeof getTemplatesByCreator>>,
  TError = unknown,
>(
  userId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTemplatesByCreator>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTemplatesByCreator>>,
          TError,
          Awaited<ReturnType<typeof getTemplatesByCreator>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTemplatesByCreator<
  TData = Awaited<ReturnType<typeof getTemplatesByCreator>>,
  TError = unknown,
>(
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTemplatesByCreator>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTemplatesByCreator>>,
          TError,
          Awaited<ReturnType<typeof getTemplatesByCreator>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTemplatesByCreator<
  TData = Awaited<ReturnType<typeof getTemplatesByCreator>>,
  TError = unknown,
>(
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTemplatesByCreator>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetTemplatesByCreator<
  TData = Awaited<ReturnType<typeof getTemplatesByCreator>>,
  TError = unknown,
>(
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTemplatesByCreator>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetTemplatesByCreatorQueryOptions(userId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}
